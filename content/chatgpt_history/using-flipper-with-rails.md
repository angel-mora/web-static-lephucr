---
title: Using Flipper with Rails
tags: []
created: '2025-07-19'
updated: '2025-07-19'
summary: "\U0001F64B **You:**  Flipper gem allows to have separate routing and controllers
  for a new version of an existing page? How easy it is to use? Show code"
draft: false
---

# Using Flipper with Rails

## ðŸ§  Full Chat

ðŸ™‹ **You:**

Flipper gem allows to have separate routing and controllers for a new version of an existing page? How easy it is to use? Show code

---

ðŸ¤– **Assistant:**

The Flipper gem is primarily used for feature flagging, which means turning features on and off for specific users, groups, percentages, etc. It doesn't natively provide separate routing or controllers for different versions of a page; however, you can certainly use Flipper to control which version of a page a user sees.

Here's a basic guide on how to use Flipper to show different versions of a page:

1. **Setup Flipper**

First, add the gem to your `Gemfile`:

```ruby
gem 'flipper'
gem 'flipper-active_record' # If you're using ActiveRecord
```

Then, run:

```bash
bundle install
```

2. **Setting up Flipper with ActiveRecord**

Create a migration for Flipper tables:

```bash
rails generate flipper:active_record
rails db:migrate
```

Initialize Flipper:

```ruby
# config/initializers/flipper.rb

require 'flipper/adapters/active_record'

Flipper.configure do |config|
  config.default do
    adapter = Flipper::Adapters::ActiveRecord.new
    Flipper.new(adapter)
  end
end
```

3. **Use Flipper in your controllers**

Assuming you have two versions of a page (v1 and v2), you can use Flipper to determine which version a user should see:

```ruby
class PagesController < ApplicationController
  def show
    if Flipper.enabled?(:new_version, current_user) # assuming you have a method called current_user
      render 'v2_show'
    else
      render 'v1_show'
    end
  end
end
```

You could also control your routes or different controllers using a similar approach, but that'd be more complex and probably not the most elegant use of Flipper.

4. **Enable/Disable the feature**

You can enable the feature for specific users:

```ruby
Flipper.enable_actor(:new_version, user)
```

Or for a percentage of users:

```ruby
Flipper.enable_percentage_of_actors(:new_version, 10) # 10% of users
```

Remember, while Flipper can help in controlling which version of a page to render, the responsibility of maintaining separate routes, views, and controllers still falls on you. If you truly need multiple versions of an API or page, consider using versioning techniques in Rails.

---

ðŸ™‹ **You:**

How it helps in the db side? What those migrations do?

---

ðŸ¤– **Assistant:**

Flipper, when combined with `flipper-active_record`, uses the database to store the feature flags and their states. This allows for persistence across application restarts and provides an easy way to manage and check feature flag states.

When you set up Flipper with ActiveRecord, it requires certain tables to store its data:

1. **flipper_features**: This table stores the features you've defined. Each feature is essentially a row with a name.

2. **flipper_gates**: This table is more dynamic and stores the state of each feature gate for every feature. For example, if you've enabled a feature for a specific user or a percentage of users, that information is stored here.

The migrations generated by `rails generate flipper:active_record` set up these tables.

Here's a rough idea of what the tables might look like:

**flipper_features**:
- id
- name (name of the feature, like `:new_version`)

**flipper_gates**:
- id
- feature_key (links to flipper_features table)
- key (the type of gate: actor, boolean, group, percentage_of_actors, percentage_of_time)
- value (the actual value, like a user id for an actor gate, or a percentage for percentage gates)

By storing this data in the database:
- **Persistence**: Your feature flags will persist across restarts.
- **Flexibility**: You can easily change the status of a feature flag directly from the database if needed.
- **Consistency**: If you have multiple instances of your application running, they all read the feature flag state from a centralized location (the database), ensuring consistency across all instances.
- **Auditability**: With the data in the database, you can also keep track of when and how feature flags are changed over time (especially if combined with other tools or logging).

However, keep in mind that querying the database for every feature flag check can introduce overhead. Flipper provides caching mechanisms to help reduce this overhead, which you might want to explore if performance becomes a concern.