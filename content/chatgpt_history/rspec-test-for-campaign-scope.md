---
title: RSpec Test for Campaign Scope
tags: []
created: '2025-07-19'
updated: '2025-07-19'
summary:
draft: false
---

# RSpec Test for Campaign Scope

## âœ… TODOs


## ðŸ“Œ Summary
could you tell me what I am missing to test correctly my scope in rspec?

## ðŸ§  Full Chat


could you tell me what I am missing to test correctly my scope in rspec?
scope :created_between, ->(start_date, end_date) { where(created_at: start_date..end_date) }
    describe 'created_between' do
      subject(:created_between) { described_class.created_between.to_sql }

      let(:start_date) { Campaign:: }
      let(:end_date) { Campaign:: }

      it { expect(created_between).to include("WHERE `campaingns`.`created_at` = '#{start_date} AND #{end_date}'") }
    end
the model is called Campaing

There are a few aspects in your RSpec test for the `created_between` scope that need to be adjusted to ensure it works correctly:

1. **Properly Setting `start_date` and `end_date`:** You haven't completed the definitions for `start_date` and `end_date`. These should be set to specific date or datetime values. For instance, you could use:

   ```ruby
   let(:start_date) { Date.new(2023, 1, 1) }
   let(:end_date) { Date.new(2023, 1, 31) }
   ```

2. **Correctly Formatting the Expected SQL Query:** The expected SQL query string in your test seems to have a syntax issue. The `created_at` field should be checked for a range, not an equality (`=`). The correct SQL query for a range check uses the `BETWEEN` keyword. Your expectation should be adjusted to match the actual SQL generated by the scope:

   ```ruby
   it { expect(created_between).to include("WHERE `campaigns`.`created_at` BETWEEN '#{start_date}' AND '#{end_date}'") }
   ```

   Note: Make sure you spell "campaigns" correctly in your test (it was misspelled as `campaingns` in your example).

3. **Using the Correct Model Name:** Ensure that the model name is correctly spelled as `Campaign` in your tests, as misspellings will cause failures. This is important because `described_class` should reference the correct model class.

4. **Handling Time Zones (if applicable):** If your application uses time zones, make sure the `start_date` and `end_date` are set in the correct time zone. This can impact the results and the correctness of your test.

5. **Verifying Scope Logic:** Ensure that the logic inside your scope (`where(created_at: start_date..end_date)`) correctly matches your requirements and generates the expected SQL.

After making these adjustments, your test should look something like this:

```ruby
describe 'created_between' do
  subject(:created_between) { described_class.created_between(start_date, end_date).to_sql }

  let(:start_date) { Date.new(2023, 1, 1) }
  let(:end_date) { Date.new(2023, 1, 31) }

  it { expect(created_between).to include("WHERE `campaigns`.`created_at` BETWEEN '#{start_date}' AND '#{end_date}'") }
end
```

This will properly set up your test to evaluate the `created_between` scope in your `Campaign` model.

Write specs for differential parts of the queries in the following scopes
ReviewStats::CategoryReviewCount.by_name('Portfolio Management').to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`name` LIKE '%Portfolio Management%'"
ReviewStats::CategoryReviewCount.by_category_status(:published).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`status` = 'published'"
ReviewStats::CategoryReviewCount.by_category_manager(1).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`category_manager_id` = 1"
ReviewStats::CategoryReviewCount.by_research_rep(1).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`research_owner_id` = 1"
ReviewStats::CategoryReviewCount.by_category_type(:parent).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`is_parent_category` = TRUE"
ReviewStats::CategoryReviewCount.by_category_publish_status(false).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`published` = FALSE"
ReviewStats::CategoryReviewCount.by_user_preference(1).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `user_categories_coverages` ON `user_categories_coverages`.`deleted_at` IS NULL AND `user_categories_coverages`.`category_id` = `categories`.`id` WHERE `categories`.`deleted_at` IS NULL AND `user_categories_coverages`.`user_id` = 1"
ReviewStats::CategoryReviewCount.categories_published_to_site.to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`published` = TRUE AND `categories`.`show_category` = TRUE"
iewStats::CategoryReviewCount.with_service_context(false).to_sql
"SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `category_review_counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`context` != 'service'"

To write RSpec tests for each of these scopes, you'll want to ensure that the SQL generated by each scope matches the expected SQL string. Here's how you could structure your tests for each scope:

### 1. `by_name`
```ruby
describe '.by_name' do
  subject { ReviewStats::CategoryReviewCount.by_name('Portfolio Management').to_sql }

  it 'generates the correct SQL for name filtering' do
    expect(subject).to include("INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL")
    expect(subject).to include("WHERE `categories`.`name` LIKE '%Portfolio Management%'")
  end
end
```

### 2. `by_category_status`
```ruby
describe '.by_category_status' do
  subject { ReviewStats::CategoryReviewCount.by_category_status(:published).to_sql }

  it 'generates the correct SQL for status filtering' do
    expect(subject).to include("WHERE `categories`.`status` = 'published'")
  end
end
```

### 3. `by_category_manager`
```ruby
describe '.by_category_manager' do
  subject { ReviewStats::CategoryReviewCount.by_category_manager(1).to_sql }

  it 'generates the correct SQL for category manager filtering' do
    expect(subject).to include("WHERE `categories`.`category_manager_id` = 1")
  end
end
```

### 4. `by_research_rep`
```ruby
describe '.by_research_rep' do
  subject { ReviewStats::CategoryReviewCount.by_research_rep(1).to_sql }

  it 'generates the correct SQL for research owner filtering' do
    expect(subject).to include("WHERE `categories`.`research_owner_id` = 1")
  end
end
```

### 5. `by_category_type`
```ruby
describe '.by_category_type' do
  subject { ReviewStats::CategoryReviewCount.by_category_type(:parent).to_sql }

  it 'generates the correct SQL for category type filtering' do
    expect(subject).to include("WHERE `categories`.`is_parent_category` = TRUE")
  end
end
```

### 6. `by_category_publish_status`
```ruby
describe '.by_category_publish_status' do
  subject { ReviewStats::CategoryReviewCount.by_category_publish_status(false).to_sql }

  it 'generates the correct SQL for publish status filtering' do
    expect(subject).to include("WHERE `categories`.`published` = FALSE")
  end
end
```

### 7. `by_user_preference`
```ruby
describe '.by_user_preference' do
  subject { ReviewStats::CategoryReviewCount.by_user_preference(1).to_sql }

  it 'generates the correct SQL for user preference filtering' do
    expect(subject).to include("INNER JOIN `user_categories_coverages`")
    expect(subject).to include("WHERE `user_categories_coverages`.`user_id` = 1")
  end
end
```

### 8. `categories_published_to_site`
```ruby
describe '.categories_published_to_site' do
  subject { ReviewStats::CategoryReviewCount.categories_published_to_site.to_sql }

  it 'generates the correct SQL for categories published to site' do
    expect(subject).to include("WHERE `categories`.`published` = TRUE")
    expect(subject).to include("AND `categories`.`show_category` = TRUE")
  end
end
```

### 9. `with_service_context`
```ruby
describe '.with_service_context' do
  subject { ReviewStats::CategoryReviewCount.with_service_context(false).to_sql }

  it 'generates the correct SQL for service context filtering' do
    expect(subject).to include("WHERE `categories`.`context` != 'service'")
  end
end
```

Each test should be placed within your RSpec test suite in the appropriate context or describe block for `ReviewStats::CategoryReviewCount`. The `subject` line in each test sets the SQL query to be tested, and the `it` block includes expectations that verify parts of the SQL query match what is expected. This approach ensures that your scopes are generating the correct SQL.

Those are not the only clauses in WHERE statements. Please include a regex in your expected string so it catches what you are testing as part and not the only clause inside the WHERE.
Failures:

  1) ReviewStats::CategoryReviewCount scopes .by_category_publish_status generates the correct SQL for publish status filtering
     Failure/Error: expect(subject).to include("WHERE `categories`.`published` = FALSE")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori..._counts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`published` = FALSE" to include "WHERE `categories`.`published` = FALSE"
     # ./spec/models/review_stats/category_review_count_spec.rb:57:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  2) ReviewStats::CategoryReviewCount scopes .by_user_preference generates the correct SQL for user preference filtering
     Failure/Error: expect(subject).to include("WHERE `user_categories_coverages`.`user_id` = 1")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `user_categories_coverage...egories`.`id` WHERE `categories`.`deleted_at` IS NULL AND `user_categories_coverages`.`user_id` = 1" to include "WHERE `user_categories_coverages`.`user_id` = 1"
     # ./spec/models/review_stats/category_review_count_spec.rb:66:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  3) ReviewStats::CategoryReviewCount scopes .categories_published_to_site generates the correct SQL for categories published to site
     Failure/Error: expect(subject).to include("WHERE `categories`.`published` = TRUE")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori...s`.`deleted_at` IS NULL AND `categories`.`published` = TRUE AND `categories`.`show_category` = TRUE" to include "WHERE `categories`.`published` = TRUE"
     # ./spec/models/review_stats/category_review_count_spec.rb:74:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  4) ReviewStats::CategoryReviewCount scopes .with_service_context generates the correct SQL for service context filtering
     Failure/Error: expect(subject).to include("WHERE `categories`.`context` != 'service'")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori...unts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`context` != 'service'" to include "WHERE `categories`.`context` != 'service'"
     # ./spec/models/review_stats/category_review_count_spec.rb:83:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  5) ReviewStats::CategoryReviewCount scopes .by_name generates the correct SQL for name filtering
     Failure/Error: expect(subject).to include("WHERE `categories`.`name` LIKE '%Portfolio Management%'")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori...y_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`name` LIKE '%Portfolio Management%'" to include "WHERE `categories`.`name` LIKE '%Portfolio Management%'"
     # ./spec/models/review_stats/category_review_count_spec.rb:17:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  6) ReviewStats::CategoryReviewCount scopes .by_category_manager generates the correct SQL for category manager filtering
     Failure/Error: expect(subject).to include("WHERE `categories`.`category_manager_id` = 1")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori...s`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`category_manager_id` = 1" to include "WHERE `categories`.`category_manager_id` = 1"
     # ./spec/models/review_stats/category_review_count_spec.rb:33:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>'

  7) ReviewStats::CategoryReviewCount scopes .by_research_rep generates the correct SQL for research owner filtering
     Failure/Error: expect(subject).to include("WHERE `categories`.`research_owner_id` = 1")
       expected "SELECT `category_review_counts`.* FROM `category_review_counts` INNER JOIN `categories` ON `categori...nts`.`category_id` WHERE `categories`.`deleted_at` IS NULL AND `categories`.`research_owner_id` = 1" to include "WHERE `categories`.`research_owner_id` = 1"
     # ./spec/models/review_stats/category_review_count_spec.rb:41:in `block (4 levels) in <module:ReviewStats>'
     # -e:1:in `<main>
Please explain the regex you use and what the problem was so I can explain to jr dev

I understand your issue. In your tests, the SQL strings you're expecting are not matching the actual SQL because the `include` matcher is looking for an exact substring match, but the actual SQL contains additional clauses in the `WHERE` part. To resolve this, we need to use a regular expression (regex) that matches the expected clause as a part of the entire `WHERE` statement, rather than the entire `WHERE` clause.

Let's go through the necessary adjustments with examples and explanations for each scope:

### 1. `by_name`
```ruby
describe '.by_name' do
  subject { ReviewStats::CategoryReviewCount.by_name('Portfolio Management').to_sql }

  it 'generates the correct SQL for name filtering' do
    expect(subject).to match(/WHERE .*`categories`.`name` LIKE '%Portfolio Management%'/)
  end
end
```
Explanation: The regex `/WHERE .*`categories`.`name` LIKE '%Portfolio Management%'` checks for any string that starts with "WHERE", followed by any characters (.*), and then contains the specific clause for the name.

### 2. `by_category_status`
```ruby
describe '.by_category_status' do
  subject { ReviewStats::CategoryReviewCount.by_category_status(:published).to_sql }

  it 'generates the correct SQL for status filtering' do
    expect(subject).to match(/WHERE .*`categories`.`status` = 'published'/)
  end
end
```
Explanation: This regex looks for a string starting with "WHERE", followed by any characters, and then the specific status clause.

### 3. `by_category_manager`
```ruby
describe '.by_category_manager' do
  subject { ReviewStats::CategoryReviewCount.by_category_manager(1).to_sql }

  it 'generates the correct SQL for category manager filtering' do
    expect(subject).to match(/WHERE .*`categories`.`category_manager_id` = 1/)
  end
end
```
Explanation: Similar to the above, but for the category manager clause.

### 4. `by_research_rep`
```ruby
describe '.by_research_rep' do
  subject { ReviewStats::CategoryReviewCount.by_research_rep(1).to_sql }

  it 'generates the correct SQL for research owner filtering' do
    expect(subject).to match(/WHERE .*`categories`.`research_owner_id` = 1/)
  end
end
```

### 5. `by_category_type`
```ruby
describe '.by_category_type' do
  subject { ReviewStats::CategoryReviewCount.by_category_type(:parent).to_sql }

  it 'generates the correct SQL for category type filtering' do
    expect(subject).to match(/WHERE .*`categories`.`is_parent_category` = TRUE/)
  end
end
```

### 6. `by_category_publish_status`
```ruby
describe '.by_category_publish_status' do
  subject { ReviewStats::CategoryReviewCount.by_category_publish_status(false).to_sql }

  it 'generates the correct SQL for publish status filtering' do
    expect(subject).to match(/WHERE .*`categories`.`published` = FALSE/)
  end
end
```

### 7. `by_user_preference`
```ruby
describe '.by_user_preference' do
  subject { ReviewStats::CategoryReviewCount.by_user_preference(1).to_sql }

  it 'generates the correct SQL for user preference filtering' do
    expect(subject).to match(/WHERE .*`user_categories_coverages`.`user_id` = 1/)
  end
end
```

### 8. `categories_published_to_site`
```ruby
describe '.categories_published_to_site' do
  subject { ReviewStats::CategoryReviewCount.categories_published_to_site.to_sql }

  it 'generates the correct SQL for categories published to site' do
    expect(subject).to match(/WHERE .*`categories`.`published` = TRUE/)
  end
end
```

### 9. `with_service_context`
```ruby
describe '.with_service_context' do
  subject { ReviewStats::CategoryReviewCount.with_service_context(false).to_sql }

  it 'generates the correct SQL for service context filtering' do
    expect(subject).to match(/WHERE .*`categories`.`context` != 'service'/)
  end
end
```

By using regex, you're allowing for other parts of the SQL query to exist in the `WHERE` clause, focusing only on the specific part you want to test. The pattern `/WHERE .*<your specific condition>/` accounts for any preceding conditions in the `WHERE` clause before reaching the condition you're testing. This approach is more flexible and robust for SQL string matching in your tests.

explain diff of this statement agains the includes one in the by_name scope
match(/WHERE .*`categories`.`name` LIKE '%Portfolio Management%'/)

Certainly! Let's compare the two different RSpec matchers: `include` and `match` with a regex, specifically in the context of your `by_name` scope test.

### `include` Matcher
- The `include` matcher is used to check if a given string contains another string exactly as specified.
- Example usage: `expect(subject).to include("WHERE `categories`.`name` LIKE '%Portfolio Management%'")`
- This expects the `subject` string to contain the exact phrase `"WHERE `categories`.`name` LIKE '%Portfolio Management%'"`. 
- The limitation is that it expects this exact substring in the `subject`. If there are any additional characters or conditions in the `WHERE` clause of your SQL query, this test will fail even if the part you're interested in (`"WHERE `categories`.`name` LIKE '%Portfolio Management%'"`) is correct. 

### `match` Matcher with Regex
- The `match` matcher, when used with a regex, is more flexible. It checks if the string matches a pattern described by the regex.
- Example usage: `expect(subject).to match(/WHERE .*`categories`.`name` LIKE '%Portfolio Management%'/)`
- This regex `/WHERE .*`categories`.`name` LIKE '%Portfolio Management%'` is interpreted as follows:
  - `WHERE` - The string must contain "WHERE".
  - `.*` - This part is a wildcard. It matches any character (except for line terminators) and any number of them. It means that anything can come after "WHERE" and before your specific condition.
  - `` `categories`.`name` LIKE '%Portfolio Management%' `` - This is the specific condition you're interested in.
- With this regex, the test will pass as long as the `subject` contains a string that starts with "WHERE", followed by any characters (which accounts for additional conditions that might be present in the SQL string), and then contains the specific condition on `categories`.`name`.

### Key Differences
1. **Flexibility**: The regex with `match` allows for additional content in the SQL string, which makes it more suitable for testing SQL queries where the exact full query is not as important as certain key parts of it.
2. **Specificity**: The `include` matcher is more rigid and specific, expecting an exact substring match. It's useful when you know the exact string you are looking for and there are no variations.

In your case, using `match` with a regex is more appropriate because your SQL queries might have additional clauses in the `WHERE` part, and you're primarily interested in testing whether a certain condition (like the `LIKE` clause for `categories`.`name`) is correctly formed and present in the query.

Specs for these scopes:
ReviewStats::OfferingReviewCount.by_name('Microsoft Teams').to_sql
"SELECT `offering_review_counts`.* FROM `offering_review_counts` INNER JOIN `offerings` ON `offerings`.`deleted_at` IS NULL AND `offerings`.`id` = `offering_review_counts`.`offering_id` INNER JOIN `vendors` ON `vendors`.`deleted_at` IS NULL AND `vendors`.`id` = `offerings`.`vendor_id` INNER JOIN `offerings` `offerings_vendors` ON `offerings_vendors`.`deleted_at` IS NULL AND `offerings_vendors`.`vendor_id` = `vendors`.`id` WHERE (`offerings`.`name` LIKE '%Microsoft Teams%' OR `vendors`.`name` LIKE '%Microsoft Teams%')"
ReviewStats::OfferingReviewCount.by_offering_publish_status(true).to_sql
"SELECT `offering_review_counts`.* FROM `offering_review_counts` INNER JOIN `offerings` ON `offerings`.`deleted_at` IS NULL AND `offerings`.`id` = `offering_review_counts`.`offering_id` WHERE `offerings`.`deleted_at` IS NULL AND `offerings`.`published` = TRUE"
ReviewStats::OfferingReviewCount.by_user_preference(1).to_sql
"SELECT `offering_review_counts`.* FROM `offering_review_counts` INNER JOIN `offerings` ON `offerings`.`deleted_at` IS NULL AND `offerings`.`id` = `offering_review_counts`.`offering_id` INNER JOIN `offering_categories` ON `offering_categories`.`deleted_at` IS NULL AND `offering_categories`.`offering_id` = `offerings`.`id` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `offering_categories`.`category_id` INNER JOIN `user_categories_coverages` ON `user_categories_coverages`.`deleted_at` IS NULL AND `user_categories_coverages`.`category_id` = `categories`.`id` WHERE `user_categories_coverages`.`deleted_at` IS NULL AND `user_categories_coverages`.`user_id` = 1"
ReviewStats::OfferingReviewCount.with_service_context(false).to_sql
"SELECT DISTINCT `offering_review_counts`.* FROM `offering_review_counts` INNER JOIN `offerings` ON `offerings`.`deleted_at` IS NULL AND `offerings`.`id` = `offering_review_counts`.`offering_id` INNER JOIN `offering_categories` ON `offering_categories`.`deleted_at` IS NULL AND `offering_categories`.`offering_id` = `offerings`.`id` INNER JOIN `categories` ON `categories`.`deleted_at` IS NULL AND `categories`.`id` = `offering_categories`.`category_id` WHERE `offerings`.`deleted_at` IS NULL AND `categories`.`context` != 'service'"
Use it { is_expected } and regex. In this case keep the merges whenever applies (I mean the sql joins)
Return only the code

Certainly! Here are the RSpec tests for each of the provided scopes using `{ is_expected }` and regex to validate the SQL queries:

### 1. `by_name`
```ruby
describe '.by_name' do
  subject { ReviewStats::OfferingReviewCount.by_name('Microsoft Teams').to_sql }

  it { is_expected.to match(/WHERE .*`offerings`.`name` LIKE '%Microsoft Teams%' OR `vendors`.`name` LIKE '%Microsoft Teams%'/) }
end
```

### 2. `by_offering_publish_status`
```ruby
describe '.by_offering_publish_status' do
  subject { ReviewStats::OfferingReviewCount.by_offering_publish_status(true).to_sql }

  it { is_expected.to match(/WHERE .*`offerings`.`published` = TRUE/) }
end
```

### 3. `by_user_preference`
```ruby
describe '.by_user_preference' do
  subject { ReviewStats::OfferingReviewCount.by_user_preference(1).to_sql }

  it { is_expected.to match(/WHERE .*`user_categories_coverages`.`user_id` = 1/) }
end
```

### 4. `with_service_context`
```ruby
describe '.with_service_context' do
  subject { ReviewStats::OfferingReviewCount.with_service_context(false).to_sql }

  it { is_expected.to match(/WHERE .*`categories`.`context` != 'service'/) }
end
```

These tests use the `{ is_expected }` syntax for a more concise format and regex to validate the presence of specific conditions within the `WHERE` clause of the SQL query, while being flexible about other parts of the query.