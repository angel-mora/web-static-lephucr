---
title: MYP-3595
tags: []
created: '2025-07-19'
updated: '2025-07-19'
summary: "\U0001F64B **You:**  # Title of the conversation: MYP-3595"
draft: false
---

# MYP-3595

## âœ… TODOs
- [ ] it over user_id. Please explain that through source to refresh my mind.
- [ ] Integrate with enum status
- [ ] refactor with method_missing if it does not interfere with other gems

## ðŸ§  Full Chat

ðŸ™‹ **You:**

# Title of the conversation: MYP-3595
# I want to understand if those rails associations commented, which are for documents table, make the documents.id association of if the fact it says source :user means that I need to do it over user_id. Please explain that through source to refresh my mind.

# Then, I need to get the following fields
# doc name
# short description
# Status - draft, published, etc.
# Owner
# Author
# sponsor
SELECT
	documents.title,
	documents.description,
	documents.status #, # TODO: Integrate with enum status
	# publishments.user_id # Better if users.name
	
FROM
	documents
	JOIN companies ON documents.company_id = companies.id
	JOIN publishments ON documents.id = publishments.document_id # owner
	JOIN authorships ON documents.id = authorships.document_id
	JOIN sponsorships ON documents.id = sponsorships.document_id # is it document_id or user_id? As in
	# has_one :owner, through: :publishment, source: :user
	# has_one :author, through: :authorship, source: :user
	# has_many :sponsors, through: :sponsorships, source: :user
WHERE
	companies.id = 194;

---

ðŸ¤– **Assistant:**

In Ruby on Rails, the `source` option in associations is used to specify the source association name for a `has_one :through` or `has_many :through` association. This option becomes necessary when the name of the source association cannot be automatically inferred from the association name.

Given the comments about the associations:

- `has_one :owner, through: :publishment, source: :user`
- `has_one :author, through: :authorship, source: :user`
- `has_many :sponsors, through: :sponsorships, source: :user`

These comments indicate that the `documents` table is associated with users (who act as owners, authors, or sponsors) through intermediary tables (`publishments`, `authorships`, `sponsorships`). The `source: :user` part means that the final target of the association is the `user` model. This means the associations are made through the `user_id` field in the intermediary tables, not directly through the `document_id` to `id` in the `users` table.

Regarding the SQL query and the fields you want to fetch:

- **doc name**: This is represented by `documents.title`.
- **short description**: This is represented by `documents.description`.
- **Status**: The status (e.g., draft, published) is indicated by `documents.status`. If you want to integrate it with an enum status, you would typically handle this in your Rails model, not directly in the SQL query.
- **Owner, Author, Sponsor**: To fetch the names of these entities, you would need to join with the `users` table for each of the associations (owner, author, sponsor). However, your current SQL query doesn't directly join the `users` table to fetch the names.

To complete the query according to your needs, you'd typically adjust it to include joins to the `users` table for each role. However, as your query is structured, it fetches the document's title, description, and status but does not yet fetch the names of the owner, author, or sponsors. You'd need to include additional joins and specify which user is related to which role based on your associations. 

Since SQL queries don't directly support Rails' `through` and `source` options, you need to manually specify the joins. For example, to get the owner's name, you'd join `publishments` to `documents`, then join `users` (where `publishments.user_id = users.id`) and select `users.name AS owner_name`. Repeat similar joins for author and sponsors.

Remember, the SQL doesn't inherently understand Rails associations; you map these out through your joins and selection criteria.

For `sponsorships`, it sounds like you're unsure if it should join on `document_id` or `user_id`. Based on your association comments, it seems like `sponsorships` should have both `document_id` (to identify the document) and `user_id` (to identify the sponsor). The `source: :user` means the association ultimately points to the `user` model, using `user_id` in the `sponsorships` table to make the connection.

---

ðŸ™‹ **You:**

This is the user.rb model:
# frozen_string_literal: true

class User < ApplicationRecord
  include UserFilters
  include AcknowledgementFilters
  include TrackAcknowledgements
  include ArelHelpers::ArelTable
  include ArelHelpers::JoinAssociation
  include ScimModel

  DEVELOPER_NAME = 'Developer User'
  SUPPORT_NAME = 'Support User'
  SUPPORT_EMAIL_PREFIX = 'infotech-support'
  PASSWORD_LENGTH = (8..72).freeze

  BASIC_ATTRIBUTES = %w[
    givenName
    familyName
    email
  ].freeze

  DEFAULT_ATTRIBUTES = %w[
    title
    primaryPhone
    mobilePhone
    department
    organization
    countryCode
    city
  ].freeze

  # ==> Gem Config
  acts_as_tenant(:company)
  acts_as_paranoid
  devise :database_authenticatable,
         :async,
         :omniauthable,
         :recoverable,
         :invitable,
         :registerable,
         :timeoutable,
         :trackable,
         :lockable,
         omniauth_providers: [:saml]
  paginates_per 10
  filterrific(
    default_filter_params: { sorted_by: 'formatted_name_asc' },
    available_filters: %i[
      sorted_by
      search_query
      filter_active
      filter_inactive
      filter_invited
      filter_not_invited
      filter_invitation_accepted
      filter_invitation_not_accepted
    ]
  )

  # ==> Normal Model Relations
  has_and_belongs_to_many :profiles
  has_many :document_assignments, dependent: :destroy
  has_many :documents, through: :document_assignments
  has_many :dispatchers, dependent: :destroy
  has_many :proto_documents, inverse_of: :user
  has_many :document_acknowledgements, inverse_of: :user, dependent: :destroy
  has_many :acknowledgeable_documents, through: :document_acknowledgements, source: :document
  has_many :document_hierarchies, through: :document_assignments
  has_many :published_documents, through: :document_hierarchies
  has_many :user_attributes, inverse_of: :user, dependent: :destroy
  has_many :user_roles, inverse_of: :user, dependent: :destroy, class_name: 'UserRole'
  has_many :roles, through: :user_roles, before_add: :reset_role, before_remove: :reset_role

  has_many :attachments_documents, inverse_of: :user
  has_many :user_profile_assignments, dependent: :destroy
  has_many :user_upload_requests, dependent: :destroy
  has_many :group_assignments, as: :groupable, dependent: :destroy
  has_many :groups, through: :group_assignments
  has_many :covid_documents, dependent: :destroy
  has_many :admin_department_tags, dependent: :destroy

  has_one :user_document_count, dependent: :destroy

  # ==> Quiz scores
  has_many :quiz_scores, dependent: :destroy

  # ==> Administrative Relations
  has_many :publishments
  has_many :sponsorships
  has_many :authorships
  has_many :owned_documents, through: :publishments, source: :document
  has_many :authored_documents, through: :authorships, source: :document
  has_many :sponsored_documents, through: :sponsorships, source: :document
  has_and_belongs_to_many :tasks, dependent: :destroy

  alias_attribute :name, :formatted_name

  # ==> Validations
  validates :formatted_name, :email, :username, presence: true
  validates :given_name, :family_name, presence: true, if: -> { !company.saml? }
  validate :username_unique, :email_unique
  validate :external_id_unique, unless: -> { external_id.nil? }
  validate :email_in_whitelisted_domain, unless: proc { looks_like_support_user? || company.demo? }
  validates :email,
            format: { with: URI::MailTo::EMAIL_REGEXP,
                              message: I18n.t('activerecord.errors.models.user.attributes.email.valid') }
  validates :password,
            presence: true,
            confirmation: true,
            length: { within: PASSWORD_LENGTH },
            allow_blank: :demo?,
            if: :password_required?
  validate :password_complexity, unless: :demo?, if: :password_required?

  # AR Hooks
  before_validation :manager_prerequisites, if: :manager?
  before_validation :generate_password, unless: -> { company.saml_or_demo? }, if: -> { password.blank? }, on: :create
  before_validation :demo!, if: -> { company.demo? }
  before_create :generate_document_token, :create_uuid
  before_update :set_formatted_name,
                if: -> { (given_name_changed? || family_name_changed?) && !formatted_name_changed? }
  after_update :update_basic_user_attributes, unless: -> { company.saml? }
  after_create :update_basic_user_attributes, unless: -> { company.saml? }
  after_create :email_new_account, if: :send_welcome_email?

  # ==> Delegates
  delegate :subdomain, to: :company

  accepts_nested_attributes_for :roles
  accepts_nested_attributes_for :user_attributes, allow_destroy: true

  # ==> Uploaders

  mount_uploader :policy_book_pdf, ProtectedPolicyBookPdfUploader  # PolicyBookPdfUploader -> SingleUseFileUploader
  mount_uploader :open_case_summary_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :document_status_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :covid_document_type_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :covid_department_acceptance_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :covid_date_of_issue_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :overdue_acknowledgement_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :document_activity_summary_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :incident_summary_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :risk_assessment_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :full_document_acknowledgement_csv, ReportCsvUploader  # SingleUseFileUploader
  mount_uploader :full_user_acknowledgement_csv, ReportCsvUploader  # SingleUseFileUploader
  mount_uploader :export_accounts_csv, ProtectedReportCsvUploader  # ReportCsvUploader -> SingleUseFileUploader
  mount_uploader :quiz_success_report_xlsx, ReportXlsxUploader  # SingleUseFileUploader
  mount_uploader :document_export_zip, DocumentExportZipUploader  # SingleUseFileUploader

  # ==> Scopes
  scope :admins, (-> { joins(:roles).where(roles: { title: 'admin' }).where.not(formatted_name: DEVELOPER_NAME) })
  scope :active_admins, (-> { admins.where(active: true) })
  scope :by_okta_group_uuid, (->(group_uuid) { joins(:groups).where(group_names: { okta_uuid: group_uuid }) })
  scope :support_users, (-> { joins(:roles).where(roles: { title: 'support_user' }, name: SUPPORT_NAME) })
  scope :developer_users, (-> { joins(:roles).where(roles: { title: 'developer' }, name: DEVELOPER_NAME) })
  scope :without_support_users, (-> { where.not(id: support_users.or(developer_users)) })
  scope :created_since, (->(time_ago) { where(created_at: time_ago..DateTime.current) })

  scope :active, (-> { where(active: true).without_support_users })
  scope :inactive, (-> { where(active: false).without_support_users })
  scope :invited, (-> { where.not(invitation_sent_at: nil) unless ActsAsTenant.current_tenant.saml_or_demo? })
  scope :not_invited, (-> { where(invitation_sent_at: nil) unless ActsAsTenant.current_tenant.saml_or_demo? })
  scope :invitation_accepted, (-> { where.not(invitation_accepted_at: nil) unless ActsAsTenant.current_tenant.saml_or_demo? })
  scope :invitation_not_accepted, (-> { where(invitation_accepted_at: nil) unless ActsAsTenant.current_tenant.saml_or_demo? })
  scope :pending_invite, -> { where(invitation_sent_at: nil, invitation_accepted_at: nil) unless ActsAsTenant.current_tenant.saml_or_demo?}

  scope :filter_active, (->(flag) { active if flag == 1 })
  scope :filter_inactive, (->(flag) { inactive if flag == 1 })
  scope :filter_invited, (->(flag) { invited if flag == 1 })
  scope :filter_not_invited, (->(flag) { not_invited if flag == 1 })
  scope :filter_invitation_accepted, (->(flag) { invitation_accepted if flag == 1 })
  scope :filter_invitation_not_accepted, (->(flag) { invitation_not_accepted if flag == 1 })

  scope :search_query, (lambda { |query|
    query = query.to_s
    return nil if query.blank?

    terms = query.downcase.split(/\s+/)

    terms = terms.map { |e| "%#{e.tr('*', '%')}%".gsub(/%+/, '%') }

    # conditional_count is used to multiply the params for the prepared statement.
    # If another ? parameter is added, this number must be increased
    conditional_count = 2

    # *terms.map duplicates the query terms and passes them to the prepared statement
    # 'AND' joins multiple searches.
    where(
      terms.map { '(users.formatted_name LIKE ? OR users.email LIKE ?)' }.join(' AND '),
      *terms.map { |e| [e] * conditional_count }.flatten
    )
  })

  scope :sorted_by, (lambda { |sort_option|
    direction = sort_option =~ /desc$/ ? 'desc' : 'asc'
    case sort_option.to_s
    when /^formatted_name_/
      order("users.formatted_name #{direction}")
    when /^email_/
      order("users.email #{direction}")
    when /^status_/
      order("users.active #{direction}")
    when /^created_/
      order("users.created_at #{direction}")
    when /^current_sign_in_/
      order("users.current_sign_in_at #{direction}")
    else
      raise(ArgumentError, "Invalid sort option: #{sort_option.inspect}")
    end
  })

  # TODO: refactor with method_missing if it does not interfere with other gems
  Role::ROLES.each do |role|
    send :define_method, "#{role}?" do
      Rails.cache.fetch(['User', id, 'roles', role]) { roles.send("only_#{role}").exists? }
    end
    send :define_method, "reset_#{role}" do
      Rails.cache.delete(['User', id, 'roles', role])
    end
  end

  # Accessor Methods not saved to model
  attr_accessor :send_invitation
...
end

Provide the right query now that you can see author, sponsor and ownerships

---

ðŸ¤– **Assistant:**

Given the provided `user.rb` model, it's a comprehensive example of a Ruby on Rails model incorporating numerous advanced features, techniques, and integrations. This model is designed to manage user data within an application that includes aspects like authentication, authorization, tenant scoping, data validation, and complex querying capabilities. Here's a breakdown of its key components and functionalities:

### Modules and Extensions
- **Modules Inclusion**: The model includes several modules for filtering (`UserFilters`, `AcknowledgementFilters`), tracking (`TrackAcknowledgements`), and SCIM support (`ScimModel`), indicating a sophisticated use of mixins for added functionalities.
- **Arel Helpers**: Uses `ArelHelpers::ArelTable` and `ArelHelpers::JoinAssociation` for advanced query composition, allowing for more readable and maintainable SQL queries within Rails.

### Constants
- Constants such as `DEVELOPER_NAME`, `SUPPORT_NAME`, and `PASSWORD_LENGTH` define fixed values used throughout the model, illustrating the use of constants to manage configuration and avoid magic numbers or strings.

### Devise and ActsAsTenant
- **Devise Setup**: Configured with `devise` for authentication, including modules for database authentication, omniauth, recoverable, invitable, and more. This shows a complex authentication system capable of handling a variety of user authentication scenarios.
- **Multi-Tenancy**: Uses `acts_as_tenant(:company)` for scoping data to a specific tenant (company), indicating a multi-tenant application design.

### Relationships
- Defines a wide range of associations (`has_many`, `has_and_belongs_to_many`, `has_one`) to other models, illustrating a complex relational database structure. It includes dependent options to manage related records' lifecycles and inverses for efficient querying.

### Validations and Callbacks
- Extensive validations (`validates`, `validate`) ensure data integrity and enforce business rules. Custom validation methods (e.g., `username_unique`, `email_unique`) are used for complex or unique validation scenarios.
- Callbacks (`before_validation`, `before_create`, `before_update`, `after_create`, `after_update`) perform actions at various stages of the record lifecycle, such as setting defaults, performing cleanup, or enforcing business logic.

### Scopes and Delegations
- **Scopes**: Defined for common queries, enabling encapsulation of SQL queries within the model and promoting reuse.
- **Delegates**: Utilizes `delegate` to simplify the access to attributes of related objects, improving encapsulation and reducing coupling.

### Uploaders
- Utilizes `mount_uploader` to attach files, indicating the use of a file uploading library (e.g., CarrierWave) for handling document uploads.

### Advanced Role Management
- Dynamic role query methods are defined using metaprogramming (`define_method`), allowing for dynamic checking of user roles. This approach facilitates a flexible and scalable authorization system.

### Custom Attributes and Nested Attributes
- Supports nested attributes for `roles` and `user_attributes`, enabling complex forms that handle multiple models in a single form.

### Observations and Potential Improvements:
- **Complexity**: The model is highly complex and feature-rich, which may introduce maintenance challenges. Refactoring and modularization could help improve maintainability.
- **Custom Validations and Callbacks**: While powerful, custom methods increase complexity. Ensuring they are well-documented and tested is crucial for long-term maintenance.
- **Scalability**: Given the model's complexity and the potential for large numbers of user records, performance should be monitored. Optimizing queries and indexing database columns might be necessary.

This model demonstrates advanced Rails model patterns, suitable for complex applications with sophisticated business logic. It's a solid example of professional Rails practices, including modularity, encapsulation, and adherence to the principle of "fat model, skinny controller" for business logic placement.

---

ðŸ™‹ **You:**

I want to get the right query from the initial question, not your description of the model implementations

---

ðŸ¤– **Assistant:**

Given the Ruby on Rails `User` model you've provided, which includes various modules, validations, associations, scopes, and methods, the task at hand seems to be constructing a query to fetch a specific subset of users based on certain conditions. However, your initial question did not specify exactly what kind of query or the conditions you're looking to apply in that query. To provide a more targeted answer, I'll need more details about the criteria you want to use for fetching users. 

For instance, if you want to fetch users based on their roles, statuses (active or inactive), whether they have accepted an invitation, or any custom attributes or relationships defined in your model, please specify. 

Could you clarify the specific query you're looking to construct with this model? For example, are you interested in:

- Active users with a specific role?
- Users who have not accepted their invitation yet?
- Users sorted by their formatted name or creation date?

Providing more context on the query conditions will allow me to give you a precise ActiveRecord query example.

---

ðŸ™‹ **You:**

# I want to understand if those rails associations commented, which are for documents table, make the documents.id association of if the fact it says source :user means that I need to do it over user_id. Please explain that through source to refresh my mind.

# Then, I need to get the following fields
# doc name
# short description
# Status - draft, published, etc.
# Owner
# Author
# sponsor
SELECT
	documents.title,
	documents.description,
	documents.status #, # TODO: Integrate with enum status
	# publishments.user_id # Better if users.name
	
FROM
	documents
	JOIN companies ON documents.company_id = companies.id
	JOIN publishments ON documents.id = publishments.document_id # owner
	JOIN authorships ON documents.id = authorships.document_id
	JOIN sponsorships ON documents.id = sponsorships.document_id # is it document_id or user_id? As in
	# has_one :owner, through: :publishment, source: :user
	# has_one :author, through: :authorship, source: :user
	# has_many :sponsors, through: :sponsorships, source: :user
WHERE
	companies.id = 194;

---

ðŸ¤– **Assistant:**

To clarify the use of the `source` option in Rails associations and how it relates to constructing your SQL query, let's break it down:

### Rails Associations and `source` Option

When you define associations in Rails, especially with `has_one` or `has_many :through` relationships, you sometimes need to specify the `source` option. This is necessary when the name of the association does not match the underlying model or table name that Rails expects based on convention.

For the associations related to the `documents` table that you've mentioned, such as `owner`, `author`, and `sponsors`, the use of `source: :user` tells Rails that the end point of these associations is the `User` model. This means that even though the association might be named differently (like `owner`, `author`, or `sponsors`), the actual source of this association is the `user` record associated through the intermediate model (`publishments`, `authorships`, `sponsorships`).

### Constructing Your SQL Query

Given the explanation above and aiming to retrieve `doc name`, `short description`, `status`, and details about `owner`, `author`, and `sponsor` from your database, your SQL query needs to join these tables correctly to fetch the desired information.

However, your current SQL snippet does not include the logic to fetch `owner`, `author`, and `sponsors` names directly, as it stops at fetching the document details and doesn't join with the `users` table to get the names.

Assuming each document has one owner, one author, and potentially multiple sponsors (but focusing on a single sponsor for simplicity), your SQL query could be extended as follows:

```sql
SELECT
    documents.title AS doc_name,
    documents.description AS short_description,
    documents.status, -- Assuming you have an enum setup, you'd handle status mapping in your application code
    owner_users.name AS Owner,
    author_users.name AS Author,
    sponsor_users.name AS Sponsor
FROM
    documents
INNER JOIN companies ON documents.company_id = companies.id
LEFT JOIN publishments ON documents.id = publishments.document_id
LEFT JOIN users AS owner_users ON publishments.user_id = owner_users.id -- Owner
LEFT JOIN authorships ON documents.id = authorships.document_id
LEFT JOIN users AS author_users ON authorships.user_id = author_users.id -- Author
LEFT JOIN sponsorships ON documents.id = sponsorships.document_id
LEFT JOIN users AS sponsor_users ON sponsorships.user_id = sponsor_users.id -- Sponsor
WHERE
    companies.id = 194;
```

Please note:
- This query assumes that `publishments`, `authorships`, and `sponsorships` tables link documents to users through a `user_id` column.
- The `LEFT JOIN` is used instead of `JOIN` to ensure that documents are listed even if one of the relationships (owner, author, sponsor) is missing.
- Since you're interested in the `owner`, `author`, and `sponsors` (users), we join the `documents` table with the `users` table via the intermediary tables (`publishments`, `authorships`, `sponsorships`), using aliases for `users` to differentiate between the roles.
- The names (`owner_users.name`, `author_users.name`, `sponsor_users.name`) are placeholders; adjust the column names based on your actual `users` table schema.

This query should give you a comprehensive view of each document, including its title, description, status, and the names of its owner, author, and a sponsor, filtered by a specific company.

---

ðŸ™‹ **You:**

Can you map the following enums in the documents table?
  enum status: {
    not_started: 0,
    draft: 1,
    pending_owner_approval: 2,
    pending_sponsor_approval: 3,
    pending_publishment: 4,
    published: 5,
    retired: 6,
    previous_version: 7
  }

---

ðŸ¤– **Assistant:**

To map the `enum status` from the `documents` table as defined in your Rails model to a SQL query, you can use a `CASE` statement within the query to convert the integer values stored in the database into their corresponding string representations as defined by the enum. This way, you can display the status as a human-readable string directly in the SQL query result.

Here's how you can extend the previous SQL query to include this mapping:

```sql
SELECT
    documents.title AS doc_name,
    documents.description AS short_description,
    CASE documents.status
        WHEN 0 THEN 'not_started'
        WHEN 1 THEN 'draft'
        WHEN 2 THEN 'pending_owner_approval'
        WHEN 3 THEN 'pending_sponsor_approval'
        WHEN 4 THEN 'pending_publishment'
        WHEN 5 THEN 'published'
        WHEN 6 THEN 'retired'
        WHEN 7 THEN 'previous_version'
    END AS status,
    owner_users.name AS Owner,
    author_users.name AS Author,
    sponsor_users.name AS Sponsor
FROM
    documents
INNER JOIN companies ON documents.company_id = companies.id
LEFT JOIN publishments ON documents.id = publishments.document_id
LEFT JOIN users AS owner_users ON publishments.user_id = owner_users.id -- Owner
LEFT JOIN authorships ON documents.id = authorships.document_id
LEFT JOIN users AS author_users ON authorships.user_id = author_users.id -- Author
LEFT JOIN sponsorships ON documents.id = sponsorships.document_id
LEFT JOIN users AS sponsor_users ON sponsorships.user_id = sponsor_users.id -- Sponsor
WHERE
    companies.id = 194;
```

In this modified query, the `CASE` statement checks the `status` column's integer value and returns the corresponding string label as defined in your Rails enum. This way, the query output will directly show the document status as `not_started`, `draft`, `pending_owner_approval`, etc., making it more understandable.

Please ensure that the column names like `owner_users.name`, `author_users.name`, and `sponsor_users.name` are correctly referencing the actual column in your `users` table that stores the user's name. If the column is differently named, you should adjust these parts of the query accordingly.