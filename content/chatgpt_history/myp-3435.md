---
title: MYP-3435
tags:
- 1c77b7
- ffffff
- binding
- add_document_header
- create_toc
- add_toc_page_numbers
- new
- create
- allow
- create_title_page
created: '2025-07-19'
updated: '2025-07-19'
summary:
draft: false
---

# MYP-3435

## âœ… TODOs


## ðŸ“Œ Summary
# frozen_string_literal: false

## ðŸ§  Full Chat


# frozen_string_literal: false

# Take the users profile and generate a full policy book from it. Will also grab documents assigned
# in the distribute documents section of the application
class PolicyBookBuilder
  include ActionView::Helpers::TextHelper
  include HexaPDF::Layout
  OUTPUT = Rails.env.development? || (Rails.env.starts_with? 'qa')
  FILEDIR = Rails.root.join('tmp', 'policy_book').to_s.freeze
  DEFAULT_FONT = 'Helvetica'.freeze
  DEFAULT_LINE_WIDTH = 0.8
  STATIC_IMAGES = {
    footer: 'policy_book/policy-book-footer.png',
    icon: 'policy_book/policy-icon.png',
    logo: 'policy_book/policy-logo.png',
    title_page: 'policy_book/policy-book-title-page.png'
  }.freeze
  TOC_Y_OFFSET_STEPS = {
    start: 12.95,
    pre_category_step: 0.25,
    post_category_step: 0.1,
    pre_document_title_step: 0.35,
    post_documents_titles_step: 0.3
  }.freeze
  TOC_PAGE_NUMBER_LINE_STRING = '. '.freeze
  TOC_MAX_LINE_LENGTH = 80
  TOC_TITLE_MAX_LINE_LENGTH = 50
  TOC_FONT_COLOUR = '#1c77b7'.freeze
  SMALL_CHARACTERS = "Itifjl1.!\'\"[]{}|:;,r ".freeze
  TOC_LINK_FONT_COLOUR = '#FFFFFF'.freeze
  TOC_PAGE_NUMBER = 2
  WIDTH = 188
  HEIGHT = 786
  FONT_FILE_NAME = 'Helvetica/Helvetica.ttf'.freeze

  def initialize(company:, user:, creation_date:)
    @company = company
    ActsAsTenant.current_tenant = @company
    @user = user
    @profile_name = @user.first_profile_name
    @policy_book = @company.policy_book || PolicyBook.new(company: @company)
    @creation_date = creation_date.in_time_zone(@company.time_zone)
    primary_document_type
  rescue StandardError => e
    log_output "#{e.message}\n\n#{e.backtrace.join("\n")}"
    raise
  end

  def filename
    "#{@policy_book.current_title.parameterize}-#{file_creation_date}.pdf"
  end

  def create
    log_output 'Creating Title Page...'
    generate_title_page

    log_output 'Creating Pre Table of Contents Page...'
    create_pre_toc

    log_output 'Creating Preface...'
    merge_preface unless @policy_book.exclude_preface?

    log_output 'Merging Documents...'
    merge_documents

    log_output 'Creating Table of Contents...'
    # 0 based index position
    # the preface can 1 - n pages
    insert_at_index = title_page_override ? (1 + page_counts[:title_page][:number_of_pages]) : 2
    insert_at_index += page_counts[:preface][:number_of_pages] unless @policy_book.exclude_preface?

    page_counts[:pre_toc] = { number_of_pages: 0 }
    add_title_toc_numbers(documents, insert_at_index)

    toc_page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    create_toc(documents, toc_page_number_starts_at, insert_at_index)

    # figure out how long the toc was and then write the document page numbers
    page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    add_toc_page_numbers(documents, insert_at_index, page_number_starts_at)

    log_output 'Creating Final Page...'
    policy_book_document.pages.insert(-1)

    log_output 'Adding Header/Footers...'
    #binding.pry
    stamp_pages

    log_output 'Writing Completed Policy Book...'
    save_policy_book!

    log_output 'Complete.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'create') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed to create policy book',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id
          }
        )
      )
    end
    false
  end

  def destroy
    log_output 'Getting destination file...'
    dest = File.join(create_tmp_directories, filename)
    log_output 'Deleting file if it exists...'
    File.delete(dest) if File.file? dest
    log_output 'File deleted.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'destroy') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed delete the policy book file',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id,
            destination_path: dest || 'no_destination_path'
          }
        )
      )
    end
    false
  end

  def policy_book_pdf_path
    @policy_book_pdf_path || ''
  end

  # Gets all of the documents into a list
  def documents
    @documents ||= @user.published_documents
                        .includes(document_category_options: :category_option)
                        .by_document_types(@policy_book.included_document_types)
                        .group_by(&:preferred_category_option)
                        .freeze
  end

  # Used for building dynamic text that depends on constituent document types
  def primary_document_type
    @primary_document_type ||= if @policy_book.include_policies?
                                 :policy
                               elsif @policy_book.include_procedures?
                                 :procedure
                               elsif @policy_book.include_forms?
                                 :form
                               else
                                 :empty
                               end
  end

  private

  def host
    @host ||= Rails.application.secrets.policy_book_asset_root_url.gsub('#', @company.subdomain)
  end

  def policy_book_document
    @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
      doc.config['page.default_media_box'] = :Letter
      font = doc.fonts.add(font_file)
      unknown_glyph = font.decode_utf8('?').first
      doc.config['font.on_missing_glyph'] = proc { unknown_glyph }
    end
  end

  def page_counts
    @page_counts ||= { toc: { number_of_pages: 0 } }
  end

  def title_page_override
    @title_page_override ||= @policy_book.title_page_override
  end

  def header_primary_colour
    @policy_book.header_primary_colour
  end

  def header_secondary_colour
    @policy_book.header_secondary_colour
  end

  def header_tertiary_colour
    @policy_book.header_tertiary_colour
  end

  def policy_book_logo_icon
    @policy_book_logo_icon ||= uri(STATIC_IMAGES[:icon]).open { |file| write_tempfile(file) }
  end

  def mypolicies_logo
    @mypolicies_logo ||= uri(STATIC_IMAGES[:logo]).open { |file| write_tempfile(file) }
  end

  def title_page_image
    @title_page_image ||= uri(STATIC_IMAGES[:title_page]).open { |file| write_tempfile(file) }
  end

  def policy_book_footer
    @policy_book_footer ||= uri(STATIC_IMAGES[:footer]).open { |file| write_tempfile(file) }
  end

  def uri(url)
    return Rails.root.join("app/assets/images/#{url}") if Rails.env.development? || Rails.env.test?

    URI.parse(ActionController::Base.helpers.asset_path(url, host: host))
  end

  def write_tempfile(file)
    Tempfile.new(['', '.png'], encoding: file.read.encoding).tap do |tmp|
      tmp.binmode
      file.rewind
      tmp.write(file.read)
    end
  end

  def company_logo
    return @company_logo if @company_logo

    @company_logo = @policy_book.logo
    begin
      @company_logo.policy_book.cache! if @policy_book.logo
    rescue StandardError
      raise 'Failed to retrieve logo.'
    end
  end

  def file_creation_date
    @creation_date.strftime('%Y-%m-%d-%H-%M-%S')
  end

  def policy_book_creation_date
    I18n.t('policy_book.pdf.body.created', date: @creation_date.to_date.to_formatted_s(:long))
  end

  # take the source file and merge it into the hexapdf document
  # also track the number of pages in the document
  def merge_document_pdf(title, source_path)
    pdf = HexaPDF::Document.open(source_path)
    page_counts[title] = { number_of_pages: pdf.pages.count }
    log_output("Document page count of: #{page_counts[title][:number_of_pages]}")
    pdf.pages.each { |page| policy_book_document.pages.add(policy_book_document.import(page)) }
  end

  # take a list of documents and merge them into the taret hexapdf object
  def merge_documents
    documents.sort_by { |category, _documents| category }.each do |arr|
      arr[1].sort_by(&:title).each do |document|
        file = document.content_pdf_file
        begin
          file.cache!
        rescue StandardError => e
          Rails.logger.tagged(self.class, 'merge_documents') do
            Rails.logger.error(
              LogEntry.new(
                description: 'Failed to find a content PDF file for document.',
                category: self.class,
                exception: e,
                extra_details: {
                  error_messages: e.message,
                  company_id: @company.id,
                  user_id: @user.id,
                  document_id: document.id
                }
              )
            )
          end
          next
        end
        log_output("Merging Document: #{document.title}")
        merge_document_pdf(document.title, file.path)
      end
    end
  rescue StandardError => e
    raise "Failed to merge documents into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def merge_preface
    file = @policy_book.preface_pdf_file
    file.cache!
    merge_document_pdf(:preface, file.path)
  rescue StandardError => e
    raise "Failed to merge preface into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the header onto a page canvas that has been passed in
  def add_header(page_canvas, page_x, page_y)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    policy_book_rectangle_end_x = sixteenth_x * 3.25
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 7.5
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 4
    # rough approximation for centering; should be 'close enough'
    header_middle_text = I18n.t("policy_book.pdf.header.middle.#{primary_document_type}")
    policy_book_title_padding = (11 - header_middle_text.length) * 0.05
    policy_book_title_position_x = sixteenth_x * (8 + policy_book_title_padding)
    rectangle_height = 45
    header_height = page_y - rectangle_height
    policy_book_font_size = 16
    info_font_size = 10
    policy_book_title_vertical_offset = 16
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(mypolicies_logo, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # header bar middle rectangle: the famous "orange box"
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, policy_book_rectangle_end_x, rectangle_height)
    page_canvas.fill

    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: policy_book_font_size)
    page_canvas.text(
      header_middle_text,
      at: [policy_book_title_position_x, header_height + policy_book_title_vertical_offset]
    )
    page_canvas.fill_color

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def ellipses(text, max_length = 75)
    (text || '').length > max_length ? text[0..(max_length - 3)].gsub(/\s\w+\s*$/, '...') : text
  end

  def options_for_document_title(title)
    title = ellipses(title)
    case title.length
    when 0..10
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.15,
        small_character_offset: 0,
        character_limit: 25 }
    when 11..25
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.13,
        small_character_offset: 0.02,
        character_limit: 25 }
    when 26..75
      split_title = word_wrap(title, line_width: 25).split("\n")
      { sections: split_title,
        font_size: split_title.length > 2 ? 13 : 15,
        no_small_character_offset: 0.1,
        character_offset: 0.1,
        small_character_offset: 0.08,
        character_limit: 25 }
    end
  end

  # stamp the header onto a document page
  def add_document_header(page_canvas, page_x, page_y, title)
    binding.pry
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 4.75
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 1.5
    rectangle_height = 45
    header_height = page_y - rectangle_height
    info_font_size = 10
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    title_options = options_for_document_title(title)

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(policy_book_logo_icon, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # policy book rectangle
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, info_rectangle_start_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: title_options.fetch(:font_size))

    # y_padding is the pixel height of the space between the text
    num_sections = title_options[:sections].length
    y_padding = (rectangle_height - (info_font_size * num_sections)) / (num_sections + 1)

    title_options[:sections].reverse.each_with_index do |section, index|
      small_char_count = section.count SMALL_CHARACTERS
      unless small_char_count.zero?
        large_char_offset = (section.length - small_char_count) * title_options.fetch(:character_offset)
      end
      large_char_offset ||= section.length * title_options.fetch(:no_small_character_offset)
      small_char_offset = small_char_count.zero? ? 0 : small_char_count * title_options.fetch(:small_character_offset)

      font_offset = title_options[:sections].length > 2 ? 8.00 : 7.75
      document_title_x = sixteenth_x * (font_offset - (large_char_offset + small_char_offset))
      document_title_y = y_padding + ((info_font_size + 1 + y_padding) * index)
      page_canvas.font(font_file, variant: :bold)
      page_canvas.text(section, at: [document_title_x, header_height + document_title_y])
      page_canvas.fill_color
    end

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the footer image on the page
  def add_footer(page_canvas, page_x, page_number)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    page_number_start_x = sixteenth_x * 15.5
    character_offset = 0.1875
    line_height = 7
    font_size = 10
    subdomain = @company.subdomain
    url = "#{subdomain}.myPolicies.com"
    url_offset_x = sixteenth_x * (8 - subdomain.length * character_offset)

    page_canvas.image(policy_book_footer, at: [0, 0], width: page_x)
    white(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)
    page_canvas.text(page_number.to_s, at: [page_number_start_x, line_height])
    fragment = build_fragment(I18n.t('policy_book.pdf.footer.table_of_contents'), font_size, TOC_PAGE_NUMBER,
                              hex_to_rgb(TOC_LINK_FONT_COLOUR), :bold)
    layouter.fit([fragment], 100, 100).draw(page_canvas, sixteenth_x, 14)
    page_canvas.text(url, at: [url_offset_x, line_height])
  rescue StandardError => e
    raise "Failed to add footer to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def generate_title_page
    if title_page_override.present?
      title_page_override.cache!
      merge_document_pdf(:title_page, title_page_override.path)
    else
      create_title_page
    end
  end

  def build_fragment(text, font_size, destination, text_colour, variant = nil)
    toc_base_font = policy_book_document.fonts.add(font_file, variant: variant)
    HexaPDF::Layout::TextFragment.create(text,
                                         { font: toc_base_font,
                                           font_size: font_size,
                                           overlays: [[:link, { dest: [destination, :XYZ, WIDTH, HEIGHT, 0] }]],
                                           fill_color: text_colour })
  end

  # create the title page for the document
  def create_title_page
    title_page = policy_book_document.pages.insert(0)
    page_x, page_y = title_page.box.value[2..3]

    page_canvas = title_page.canvas

    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    company_name_y_position = sixteenth_y * 14
    policy_book_y_position = sixteenth_y * 13.25
    profile_y_position = sixteenth_y * 12.5
    date_created_y_position = sixteenth_y * 11.5
    title_image_y_position = sixteenth_y * 2
    underline_y_position = sixteenth_y * 12.15
    underline_x_position = [sixteenth_x, sixteenth_x * 15]
    large_font_size = 30
    medium_font_size = 20

    black(page_canvas)

    page_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [sixteenth_x, company_name_y_position])

    page_canvas.font(DEFAULT_FONT, size: large_font_size)
    page_canvas.text(
      I18n.t("policy_book.pdf.title_page.subtitle.#{primary_document_type}"),
      at: [sixteenth_x, policy_book_y_position]
    )

    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(@profile_name, at: [sixteenth_x, profile_y_position])

    grey_lightish_stroke(page_canvas)
    page_canvas.line_width = DEFAULT_LINE_WIDTH
    page_canvas.line(underline_x_position[0], underline_y_position, underline_x_position[1], underline_y_position)
    page_canvas.stroke

    grey_lightish(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(policy_book_creation_date, at: [sixteenth_x, date_created_y_position])

    page_canvas.image(title_page_image, at: [0, title_image_y_position], width: page_x)
    page_counts[:title_page] = { number_of_pages: 1 }
  rescue StandardError => e
    raise "Failed to create title page for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # add a page that displayes a single title in the center of the page
  # wrapped to a certain amount on each line
  def create_pre_toc(insert_at_index = 2)
    pre_toc_page = policy_book_document.pages.insert(insert_at_index)
    page_x, page_y = pre_toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    font_size = 30
    character_offset = 0.20
    character_line_limit = 28

    pre_toc_canvas = pre_toc_page.canvas
    black(pre_toc_canvas)
    pre_toc_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)

    # split the text and center it
    wrapped_title = word_wrap(@policy_book.current_title, line_width: character_line_limit)
    title_sections = wrapped_title.split("\n")
    title_sections.each_with_index do |section, index|
      x_offset = sixteenth_x * (8 - section.length * character_offset)
      pre_toc_canvas.text(section, at: [x_offset, sixteenth_y * (8 - index)])
    end
  rescue StandardError => e
    raise "Failed to create pre table of contents for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # create the table of contents
  # split into multiple pages recursively
  def create_toc(documents, page_number, insert_at = 2)
    toc_page = policy_book_document.pages[insert_at]
    page_counts[:toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    document_title_start_x = sixteenth_x * 2
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    underline_y_position = sixteenth_y * 13.6
    underline_x_end_position = sixteenth_x * 15
    toc_title_position = [sixteenth_x * 4.9, sixteenth_y * 14]
    large_font_size = 29
    medium_font_size = 22
    small_font_size = 12

    toc_canvas = toc_page.canvas
    black(toc_canvas)

    toc_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    toc_canvas.text(I18n.t('policy_book.pdf.body.table_of_contents'), at: toc_title_position)

    grey_lightish_stroke(toc_canvas)
    toc_canvas.line_width = DEFAULT_LINE_WIDTH
    toc_canvas.line(sixteenth_x, underline_y_position, underline_x_end_position, underline_y_position)
    toc_canvas.stroke

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      toc_canvas.font(DEFAULT_FONT, size: medium_font_size)
      grey_lightish(toc_canvas)

      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      toc_canvas.text(ellipses(category, TOC_TITLE_MAX_LINE_LENGTH), at: [sixteenth_x, (sixteenth_y * y_offset) - 10])
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key? document.title

        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        dest_page_number = page_number + page_counts.dig(:pre_toc, :number_of_pages) - 1
        fragment = build_fragment(ellipses(document.title, TOC_MAX_LINE_LENGTH), small_font_size, dest_page_number,
                                  hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 600, 400).draw(toc_canvas, document_title_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      create_toc(document_index, page_number, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to create ToC for (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Add page numbers onto the table of contents.
  # Since we don't know how many pages there will be upfront, we have to
  # number the document pages after offsetting the number of table of contents pages.
  def add_toc_page_numbers(documents, start_at, page_number)
    toc_page = policy_book_document.pages[start_at]
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    padding_offset_start_x = sixteenth_x * 2
    padding_offset_stop_x = sixteenth_x * 13.5
    page_number_start_x = sixteenth_x * 14
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    small_font_size = 12
    document_title_character_offset = 0.2
    toc_dot_interval = 3.0
    padding_default = 65 # random number of text characters before running off the page

    toc_canvas = toc_page.canvas

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step] + TOC_Y_OFFSET_STEPS[:post_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key?(title)
        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        title_length = ellipses(title, TOC_MAX_LINE_LENGTH).length
        padding = padding_default - title_length
        (0..padding).each do |i|
          padding_offset = padding_offset_start_x + (sixteenth_x * (title_length * document_title_character_offset) + (sixteenth_x * (i / toc_dot_interval)))
          break if padding_offset > padding_offset_stop_x

          toc_canvas.text(TOC_PAGE_NUMBER_LINE_STRING, at: [padding_offset, (sixteenth_y * y_offset) - 8])
        end

        fragment = build_fragment(page_number.to_s, small_font_size, page_number - 1, hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 100, 100).draw(toc_canvas, page_number_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents page numbers have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_toc_page_numbers(document_index, start_at + 1, page_number)
    end
  rescue StandardError => e
    raise "Failed to add ToC page numbers for (#{start_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def add_title_toc_numbers(documents, insert_at = 2)
    toc_page = policy_book_document.pages.insert(insert_at)
    page_counts[:pre_toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    y_offset = TOC_Y_OFFSET_STEPS[:start]
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        next unless page_counts.key? document.title

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_title_toc_numbers(document_index, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to add title toc numbers (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Stamp the header and footer onto each page of the policy book
  def stamp_pages(page_number = 1)
    # remove pages that are not documents
    document_page_counts = page_counts.select { |_key, values| values.key?(:next_documents_page) }

    # title_page = 1...n
    # toc = n +1
    title_page_index = title_page_override.present? ? [*1..page_counts[:title_page][:number_of_pages]] : []
    regular_header_index = [*1..page_counts[:title_page][:number_of_pages] + 1]
    # Don't add headers to custom title pages
    regular_header_index -= title_page_index
    # offset for the preface
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:preface][:number_of_pages])).to_a if page_counts[:preface]
    # offset for the toc
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:toc][:number_of_pages])).to_a
    # last page (blank one)
    regular_header_index << policy_book_document.pages.count
    # compare policy_book_document.pages vs regular_header_index
    policy_book_document.pages.each do |page|
      if title_page_index.include?(page_number)
        page_number += 1
        next
      end
      page_x, page_y = page.box.value[2..3]
      page_canvas = page.canvas(type: :overlay)
      binding.pry
      if regular_header_index.include?(page_number)
        add_header(page_canvas, page_x, page_y)
      else
        page_number_hash = document_page_counts.select do |_key, hash|
          hash[:next_documents_page] > page_number && hash[:document_start_page] <= page_number
        end
        page_title = Hash[page_number_hash].keys.first || ''

        add_document_header(page_canvas, page_x, page_y, page_title)
      end
      add_footer(page_canvas, page_x, page_number)
      page_number += 1
    end
  rescue StandardError => e
    raise "Failed to stamp header/footer for page #{page_number}: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def save_policy_book!
    dest = File.join(create_tmp_directories, filename)
    policy_book_document.write(dest, optimize: true)
    raise "Failed to find policy book file after save: #{dest}" unless File.file? dest

    @policy_book_pdf_path = dest
  end

  # make sure that all of the folders in the tmp directory exist or create them
  def create_tmp_directories
    Dir.mkdir FILEDIR unless File.directory?(FILEDIR)

    company_dir = File.join(FILEDIR, 'company')
    Dir.mkdir company_dir unless File.directory?(company_dir)

    company_id_dir = File.join(company_dir, @company.id.to_s)
    Dir.mkdir company_id_dir unless File.directory?(company_id_dir)

    company_user_dir = File.join(company_id_dir, 'user')
    Dir.mkdir company_user_dir unless File.directory?(company_user_dir)

    company_user_id_dir = File.join(company_user_dir, @user.id.to_s)
    Dir.mkdir company_user_id_dir unless File.directory?(company_user_id_dir)

    company_user_id_dir
  end

  # Set the colour based on the RGB values passed in
  def colour(page_canvas, red, green, blue)
    page_canvas.fill_color(red, green, blue)
  end

  # set the stroke colour based on RGB values passed in
  def stroke_colour(page_canvas, red, green, blue)
    page_canvas.stroke_color(red, green, blue)
  end

  def set_canvas_colour(page_canvas, hex_colour)
    colour(page_canvas, *hex_to_rgb(hex_colour))
  end

  # Determine the luminosity of the hex colour passed in and use it to determine if
  # black or white should be used as a font colour
  def set_font_colour(page_canvas, hex_colour)
    r, g, b = hex_to_rgb(hex_colour)
    (0.2126 * r + 0.7152 * g + 0.0722 * b) <= 180 ? white(page_canvas) : black(page_canvas)
  end

  # --v
  def white(page_canvas)
    colour(page_canvas, 255, 255, 255)
  end

  # --v
  def black(page_canvas)
    colour(page_canvas, 0, 0, 0)
  end

  # --v
  def grey_lightish(page_canvas)
    colour(page_canvas, 193, 193, 193)
  end

  # --v
  def grey_lightish_stroke(page_canvas)
    stroke_colour(page_canvas, 193, 193, 193)
  end

  def hex_to_rgb(hex)
    r = hex[1..2].to_i(16)
    g = hex[3..4].to_i(16)
    b = hex[5..6].to_i(16)
    [r, g, b]
  end

  # log output to the console depending on the ENV that you are in
  def log_output(message)
    return unless OUTPUT
    return puts "PolicyBookBuilder::: #{message}" if Rails.env.development?

    Rails.logger.tagged('PolicyBookBuilder') { Rails.logger.info(message) }
  end

  def layouter
    TextLayouter.new
  end

  def font_file
    return @font_file if @font_file

    manifest_file = Rails.application.assets_manifest.assets[FONT_FILE_NAME]
    @font_file =
      if manifest_file
        File.join(Rails.application.assets_manifest.directory, manifest_file)
      else
        Rails.application.assets&.[](FONT_FILE_NAME)&.filename
      end
  end
end

For that service, help me to make these specs:
  describe '#add_document_header' do
    it 'assembles properly' do
    end

    context 'when logo' do
      it 'adds image to page canvas'
    end

    context 'when handling chars'

    it 'handles error'
  end

  describe '#create_toc' do

  end

  describe '#add_toc_page_numbers' do
    it 'sorts documents properly'
    it 'errors'
  end

I found it difficult at first glance due to the high level of coupleness of the service.


Creating test specifications for a complex service like `PolicyBookBuilder` is a great way to ensure the reliability and maintainability of your code. Given the interdependencies and the complex logic in this service, your test specs should be thorough. Here are some specifications you might consider:

### `#add_document_header`

1. **Basic Assembly Test**
   - **Description**: Tests if the method assembles the document header correctly.
   - **Spec**: 
     ```ruby
     describe '#add_document_header' do
       it 'assembles properly' do
         # Setup necessary objects (mock or real)
         # Call the method
         # Assert that the header is assembled as expected
       end
     end
     ```

2. **Logo Inclusion Test**
   - **Description**: Tests if the company logo is correctly added to the header when present.
   - **Spec**:
     ```ruby
     context 'when logo' do
       it 'adds image to page canvas' do
         # Setup with a mock company logo
         # Call the method
         # Assert that the logo is included in the header
       end
     end
     ```

3. **Character Handling Test**
   - **Description**: Tests how the method handles different characters and lengths in the title.
   - **Spec**:
     ```ruby
     context 'when handling chars' do
       it 'handles long titles correctly' do
         # Setup with a long title
         # Call the method
         # Assert that the title is handled correctly (e.g., truncated, wrapped)
       end
     end
     ```

4. **Error Handling Test**
   - **Description**: Tests the method's behavior when an error occurs (e.g., missing logo file).
   - **Spec**:
     ```ruby
     it 'handles error' do
       # Setup with an erroneous condition
       # Call the method
       # Assert that it handles the error as expected (e.g., logging, graceful degradation)
     end
     ```

### `#create_toc`

1. **Table of Contents Assembly Test**
   - **Description**: Ensures that the Table of Contents is created correctly with the right order and titles.
   - **Spec**:
     ```ruby
     describe '#create_toc' do
       it 'assembles TOC correctly' do
         # Setup necessary documents
         # Call the method
         # Assert the correct assembly of the TOC
       end
     end
     ```

### `#add_toc_page_numbers`

1. **Document Sorting Test**
   - **Description**: Verifies that documents are sorted correctly in the TOC.
   - **Spec**:
     ```ruby
     describe '#add_toc_page_numbers' do
       it 'sorts documents properly' do
         # Setup documents in unordered fashion
         # Call the method
         # Assert that documents are sorted correctly in TOC
       end
     end
     ```

2. **Error Handling in TOC Page Numbering**
   - **Description**: Tests how the method handles errors during TOC page numbering (e.g., missing pages, incorrect numbering).
   - **Spec**:
     ```ruby
     it 'handles errors' do
       # Setup a condition that would cause an error (e.g., missing page numbers)
       # Call the method
       # Assert that it handles the error as expected
     end
     ```

Given the complexity of the `PolicyBookBuilder`, you might also want to consider breaking it down into smaller, more manageable components in the future. This would make testing easier and your code more modular and maintainable.

You did not provide any actual implementation of those methods in the spec. Provide those.

Certainly! Here are some more detailed implementations for the test specifications provided earlier. Please note that these examples are illustrative and may require adjustments to fit the exact structure and dependencies of your `PolicyBookBuilder` class.

### `#add_document_header`

1. **Basic Assembly Test**
   ```ruby
   describe '#add_document_header' do
     let(:page_canvas) { instance_double('Canvas') }
     let(:page_x) { 600 }
     let(:page_y) { 800 }
     let(:title) { 'Test Document' }

     it 'assembles properly' do
       allow(page_canvas).to receive(:text)
       allow(page_canvas).to receive(:font)
       allow(page_canvas).to receive(:image)

       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_document_header(page_canvas, page_x, page_y, title)

       expect(page_canvas).to have_received(:text).with(title, anything)
       # Add more expectations based on method implementation
     end
   end
   ```

2. **Logo Inclusion Test**
   ```ruby
   context 'when logo' do
     it 'adds image to page canvas' do
       allow(page_canvas).to receive(:image)

       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_document_header(page_canvas, page_x, page_y, title)

       expect(page_canvas).to have_received(:image).with(anything, hash_including(at: [anything, anything], height: anything))
     end
   end
   ```

3. **Character Handling Test**
   ```ruby
   context 'when handling chars' do
     it 'handles long titles correctly' do
       long_title = 'A Very Long Document Title That Exceeds Normal Length'
       allow(page_canvas).to receive(:text)

       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_document_header(page_canvas, page_x, page_y, long_title)

       # Check if text was appropriately truncated or wrapped
       expect(page_canvas).to have_received(:text).with(match(/.{1,30}/), anything) # Assuming 30 is max char length per line
     end
   end
   ```

4. **Error Handling Test**
   ```ruby
   it 'handles error' do
     allow(page_canvas).to receive(:image).and_raise(StandardError, 'image not found')

     expect {
       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_document_header(page_canvas, page_x, page_y, title)
     }.to_not raise_error
   end
   ```

### `#create_toc`

1. **Table of Contents Assembly Test**
   ```ruby
   describe '#create_toc' do
     let(:documents) { [...] } # Replace with appropriate document setup

     it 'assembles TOC correctly' do
       policy_book_builder = PolicyBookBuilder.new(...)
       # Assuming create_toc method requires certain parameters
       policy_book_builder.create_toc(documents, page_number, insert_at)

       # Assert the correct assembly of the TOC
       # This can be a check for the order of documents, the correctness of page numbers, etc.
     end
   end
   ```

### `#add_toc_page_numbers`

1. **Document Sorting Test**
   ```ruby
   describe '#add_toc_page_numbers' do
     let(:unordered_documents) { [...] } # Setup documents in unordered fashion

     it 'sorts documents properly' do
       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_toc_page_numbers(unordered_documents, start_at, page_number)

       # Assert that documents are sorted correctly in TOC
       # This could involve checking the order in which methods are called on a mocked object
     end
   end
   ```

2. **Error Handling in TOC Page Numbering**
   ```ruby
   it 'handles errors' do
     allow(some_dependent_method).to receive(:some_function).and_raise(StandardError)

     expect {
       policy_book_builder = PolicyBookBuilder.new(...)
       policy_book_builder.add_toc_page_numbers(documents, start_at, page_number)
     }.to_not raise_error
   end
   ```

These examples use RSpec for testing. If you're using a different testing framework, the syntax and approach might differ. Remember that the effectiveness of these tests will depend on how well they're integrated with the rest of your test suite and how accurately they reflect the functionality of the `PolicyBookBuilder` methods.

This is where I got so far. Please provide more help for this mock to get assembled. Remember that I shared the whole service object to you previously. And remember we are rspec here.

Spec:
  describe '#add_document_header' do
    subject(:method) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

    let(:page_canvas) { HexaPDF::Content::Canvas.new(type: :overlay) }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:title) { '' }

    it 'assembles properly' do
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:rectangle)
      expect(method).not_to raise_error
    end

    context 'when logo' do
      it 'adds image to page canvas'
    end

    context 'when handling chars'

    it 'handles error'
  end

Error:
PolicyBookBuilder
  #add_document_header
    assembles properly (FAILED - 1)

Failures:

  1) PolicyBookBuilder#add_document_header assembles properly
     Failure/Error: raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"

     RuntimeError:
       Failed to add header to policy book page: Operation only allowed if current graphics object is a path or clipping path

       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/hexapdf-0.29.0/lib/hexapdf/content/canvas.rb:2428:in `raise_unless_in_path_or_clipping_path'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/hexapdf-0.29.0/lib/hexapdf/content/canvas.rb:1463:in `fill'
       /Users/angel.mora.mx/InfoTech/mypolicies/app/services/policy_book_builder.rb:419:in `add_document_header'
       /Users/angel.mora.mx/InfoTech/mypolicies/spec/services/policy_book_builder_spec.rb:222:in `block (3 levels) in <top (required)>'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:343:in `block (2 levels) in let'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:179:in `block (3 levels) in fetch_or_store'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:179:in `fetch'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:179:in `block (2 levels) in fetch_or_store'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-support-3.11.0/lib/rspec/support/reentrant_mutex.rb:23:in `synchronize'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:178:in `block in fetch_or_store'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:177:in `fetch'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:177:in `fetch_or_store'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/memoized_helpers.rb:343:in `block in let'
       /Users/angel.mora.mx/InfoTech/mypolicies/spec/services/policy_book_builder_spec.rb:232:in `block (3 levels) in <top (required)>'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:263:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:263:in `block in run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:511:in `block in with_around_and_singleton_context_hooks'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:468:in `block in with_around_example_hooks'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:486:in `block in run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:626:in `block in run_around_example_hooks_for'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:352:in `call'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-rails-6.0.1/lib/rspec/rails/adapters.rb:75:in `block (2 levels) in <module:MinitestLifecycleAdapter>'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:390:in `execute_with'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:628:in `block (2 levels) in run_around_example_hooks_for'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:352:in `call'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/webmock-3.14.0/lib/webmock/rspec.rb:37:in `block (2 levels) in <main>'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:390:in `execute_with'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:628:in `block (2 levels) in run_around_example_hooks_for'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:352:in `call'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-retry-0.6.2/lib/rspec/retry.rb:124:in `block in run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-retry-0.6.2/lib/rspec/retry.rb:110:in `loop'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-retry-0.6.2/lib/rspec/retry.rb:110:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-retry-0.6.2/lib/rspec_ext/rspec_ext.rb:12:in `run_with_retry'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-retry-0.6.2/lib/rspec/retry.rb:37:in `block (2 levels) in setup'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:457:in `instance_exec'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:390:in `execute_with'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:628:in `block (2 levels) in run_around_example_hooks_for'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:352:in `call'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:629:in `run_around_example_hooks_for'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/hooks.rb:486:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:468:in `with_around_example_hooks'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:511:in `with_around_and_singleton_context_hooks'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example.rb:259:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:646:in `block in run_examples'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:642:in `map'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:642:in `run_examples'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:607:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:608:in `block in run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:608:in `map'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/example_group.rb:608:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:121:in `block (3 levels) in run_specs'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:121:in `map'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:121:in `block (2 levels) in run_specs'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/configuration.rb:2068:in `with_suite_hooks'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:116:in `block in run_specs'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/reporter.rb:74:in `report'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:115:in `run_specs'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:89:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:71:in `run'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/lib/rspec/core/runner.rb:45:in `invoke'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/rspec-core-3.11.0/exe/rspec:4:in `<main>'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/spring-commands-rspec-1.0.4/lib/spring/commands/rspec.rb:18:in `load'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/spring-commands-rspec-1.0.4/lib/spring/commands/rspec.rb:18:in `call'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:10:in `block in fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:10:in `block in fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:8:in `fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:8:in `fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:27:in `fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:8:in `fork'
       /Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/gems/3.0.0/gems/activesupport-6.1.7.3/lib/active_support/fork_tracker.rb:27:in `fork'
       <internal:/Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/site_ruby/3.0.0/rubygems/core_ext/kernel_require.rb>:85:in `require'
       <internal:/Users/angel.mora.mx/.rbenv/versions/3.0.6/lib/ruby/site_ruby/3.0.0/rubygems/core_ext/kernel_require.rb>:85:in `require'
       -e:1:in `<main>'
     # ./app/services/policy_book_builder.rb:469:in `rescue in add_document_header'
     # ./app/services/policy_book_builder.rb:398:in `add_document_header'
     # ./spec/services/policy_book_builder_spec.rb:222:in `block (3 levels) in <top (required)>'
     # ./spec/services/policy_book_builder_spec.rb:232:in `block (3 levels) in <top (required)>'
     # -e:1:in `<main>'
     # ------------------
     # --- Caused by: ---
     # HexaPDF::Error:
     #   Operation only allowed if current graphics object is a path or clipping path
     #   ./app/services/policy_book_builder.rb:419:in `add_document_header'

The error you're encountering, `Operation only allowed if current graphics object is a path or clipping path`, suggests that there's an issue with how graphics operations are being performed on the `HexaPDF::Content::Canvas` object in your `add_document_header` method.

When working with HexaPDF and its canvas, certain operations like `fill` and `stroke` are only allowed if the canvas is in a specific state (like having an active path). This error typically arises when such operations are called outside the expected context or state.

### Addressing the Error

To address this, you need to ensure that the canvas operations in `add_document_header` are correctly sequenced. For instance, if you're calling `canvas.fill`, there should be an active path (like a rectangle or line) that it can fill.

In your test setup, you're mocking `page_canvas` but not necessarily capturing the sequencing or state dependencies of HexaPDF's canvas operations. This might be leading to state inconsistencies.

### Suggested Changes

1. **Mocking Canvas Operations More Accurately:**
   You need to mock the canvas operations in a way that respects the sequence and state requirements of HexaPDF. This may involve mocking not just the end operations like `fill_color` and `rectangle`, but also the intermediate steps that lead to these operations.

2. **Revisiting `add_document_header` Method:**
   Review the implementation of `add_document_header` in your `PolicyBookBuilder` service. Ensure that all graphic operations are correctly sequenced. For example, if you're using `fill` or `stroke`, check that there's an active path. If you're starting a new path, make sure to close or end the previous one appropriately.

3. **Error Handling:**
   The method should gracefully handle situations where the necessary graphics operations can't be performed (perhaps due to missing or incorrect data). Catching and logging these errors can help avoid runtime exceptions.

4. **Testing for Specific Canvas States:**
   In your tests, consider mocking the state of the canvas more precisely. For example, if your method expects a path to be present, your test setup should reflect this.

### Example Test Adjustment

Here's an adjusted version of your test, focusing on the basic assembly. Note that this example assumes certain behaviors about your `add_document_header` method which may not be accurate, so adjust as necessary:

```ruby
describe '#add_document_header' do
  subject(:method_call) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

  let(:page_canvas) { instance_double('HexaPDF::Content::Canvas') }
  let(:page_x) { 612 }
  let(:page_y) { 792 }
  let(:title) { 'Sample Title' }
  let(:builder) { PolicyBookBuilder.new(...) } # Additional setup as required

  before do
    allow(page_canvas).to receive(:fill_color)
    allow(page_canvas).to receive(:rectangle).and_return(page_canvas) # Assuming this creates a path
    allow(page_canvas).to receive(:fill) # Assuming this is the operation that fills the path
    # ... other method stubs as required by your actual method
  end

  it 'assembles properly' do
    expect { method_call }.not_to raise_error
    # Additional expectations to ensure the method behaves as expected
  end
end
```

In this example, `rectangle` is stubbed to return the canvas itself, mimicking the behavior of setting up a path. The actual implementation in your service will dictate how precisely you need to mock these operations.

Here's the whole service so make sure you build the pdf properly, according to the policy_book_document method:

# frozen_string_literal: false

# Take the users profile and generate a full policy book from it. Will also grab documents assigned
# in the distribute documents section of the application
class PolicyBookBuilder
  include ActionView::Helpers::TextHelper
  include HexaPDF::Layout
  OUTPUT = Rails.env.development? || (Rails.env.starts_with? 'qa')
  FILEDIR = Rails.root.join('tmp', 'policy_book').to_s.freeze
  DEFAULT_FONT = 'Helvetica'.freeze
  DEFAULT_LINE_WIDTH = 0.8
  STATIC_IMAGES = {
    footer: 'policy_book/policy-book-footer.png',
    icon: 'policy_book/policy-icon.png',
    logo: 'policy_book/policy-logo.png',
    title_page: 'policy_book/policy-book-title-page.png'
  }.freeze
  TOC_Y_OFFSET_STEPS = {
    start: 12.95,
    pre_category_step: 0.25,
    post_category_step: 0.1,
    pre_document_title_step: 0.35,
    post_documents_titles_step: 0.3
  }.freeze
  TOC_PAGE_NUMBER_LINE_STRING = '. '.freeze
  TOC_MAX_LINE_LENGTH = 80
  TOC_TITLE_MAX_LINE_LENGTH = 50
  TOC_FONT_COLOUR = '#1c77b7'.freeze
  SMALL_CHARACTERS = "Itifjl1.!\'\"[]{}|:;,r ".freeze
  TOC_LINK_FONT_COLOUR = '#FFFFFF'.freeze
  TOC_PAGE_NUMBER = 2
  WIDTH = 188
  HEIGHT = 786
  FONT_FILE_NAME = 'Helvetica/Helvetica.ttf'.freeze

  def initialize(company:, user:, creation_date:)
    @company = company
    ActsAsTenant.current_tenant = @company
    @user = user
    @profile_name = @user.first_profile_name
    @policy_book = @company.policy_book || PolicyBook.new(company: @company)
    @creation_date = creation_date.in_time_zone(@company.time_zone)
    primary_document_type
  rescue StandardError => e
    log_output "#{e.message}\n\n#{e.backtrace.join("\n")}"
    raise
  end

  def filename
    "#{@policy_book.current_title.parameterize}-#{file_creation_date}.pdf"
  end

  def create
    log_output 'Creating Title Page...'
    generate_title_page

    log_output 'Creating Pre Table of Contents Page...'
    create_pre_toc

    log_output 'Creating Preface...'
    merge_preface unless @policy_book.exclude_preface?

    log_output 'Merging Documents...'
    merge_documents

    log_output 'Creating Table of Contents...'
    # 0 based index position
    # the preface can 1 - n pages
    insert_at_index = title_page_override ? (1 + page_counts[:title_page][:number_of_pages]) : 2
    insert_at_index += page_counts[:preface][:number_of_pages] unless @policy_book.exclude_preface?

    page_counts[:pre_toc] = { number_of_pages: 0 }
    add_title_toc_numbers(documents, insert_at_index)

    toc_page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    create_toc(documents, toc_page_number_starts_at, insert_at_index)

    # figure out how long the toc was and then write the document page numbers
    page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    add_toc_page_numbers(documents, insert_at_index, page_number_starts_at)

    log_output 'Creating Final Page...'
    policy_book_document.pages.insert(-1)

    log_output 'Adding Header/Footers...'
    stamp_pages

    log_output 'Writing Completed Policy Book...'
    save_policy_book!

    log_output 'Complete.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'create') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed to create policy book',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id
          }
        )
      )
    end
    false
  end

  def destroy
    log_output 'Getting destination file...'
    dest = File.join(create_tmp_directories, filename)
    log_output 'Deleting file if it exists...'
    File.delete(dest) if File.file? dest
    log_output 'File deleted.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'destroy') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed delete the policy book file',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id,
            destination_path: dest || 'no_destination_path'
          }
        )
      )
    end
    false
  end

  def policy_book_pdf_path
    @policy_book_pdf_path || ''
  end

  # Gets all of the documents into a list
  def documents
    @documents ||= @user.published_documents
                        .includes(document_category_options: :category_option)
                        .by_document_types(@policy_book.included_document_types)
                        .group_by(&:preferred_category_option)
                        .freeze
  end

  # Used for building dynamic text that depends on constituent document types
  def primary_document_type
    @primary_document_type ||= if @policy_book.include_policies?
                                 :policy
                               elsif @policy_book.include_procedures?
                                 :procedure
                               elsif @policy_book.include_forms?
                                 :form
                               else
                                 :empty
                               end
  end

  private

  def host
    @host ||= Rails.application.secrets.policy_book_asset_root_url.gsub('#', @company.subdomain)
  end

  def policy_book_document
    @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
      doc.config['page.default_media_box'] = :Letter
      font = doc.fonts.add(font_file)
      unknown_glyph = font.decode_utf8('?').first
      doc.config['font.on_missing_glyph'] = proc { unknown_glyph }
    end
  end

  def page_counts
    @page_counts ||= { toc: { number_of_pages: 0 } }
  end

  def title_page_override
    @title_page_override ||= @policy_book.title_page_override
  end

  def header_primary_colour
    @policy_book.header_primary_colour
  end

  def header_secondary_colour
    @policy_book.header_secondary_colour
  end

  def header_tertiary_colour
    @policy_book.header_tertiary_colour
  end

  def policy_book_logo_icon
    @policy_book_logo_icon ||= uri(STATIC_IMAGES[:icon]).open { |file| write_tempfile(file) }
  end

  def mypolicies_logo
    @mypolicies_logo ||= uri(STATIC_IMAGES[:logo]).open { |file| write_tempfile(file) }
  end

  def title_page_image
    @title_page_image ||= uri(STATIC_IMAGES[:title_page]).open { |file| write_tempfile(file) }
  end

  def policy_book_footer
    @policy_book_footer ||= uri(STATIC_IMAGES[:footer]).open { |file| write_tempfile(file) }
  end

  def uri(url)
    return Rails.root.join("app/assets/images/#{url}") if Rails.env.development? || Rails.env.test?

    URI.parse(ActionController::Base.helpers.asset_path(url, host: host))
  end

  def write_tempfile(file)
    Tempfile.new(['', '.png'], encoding: file.read.encoding).tap do |tmp|
      tmp.binmode
      file.rewind
      tmp.write(file.read)
    end
  end

  def company_logo
    return @company_logo if @company_logo

    @company_logo = @policy_book.logo
    begin
      @company_logo.policy_book.cache! if @policy_book.logo
    rescue StandardError
      raise 'Failed to retrieve logo.'
    end
  end

  def file_creation_date
    @creation_date.strftime('%Y-%m-%d-%H-%M-%S')
  end

  def policy_book_creation_date
    I18n.t('policy_book.pdf.body.created', date: @creation_date.to_date.to_formatted_s(:long))
  end

  # take the source file and merge it into the hexapdf document
  # also track the number of pages in the document
  def merge_document_pdf(title, source_path)
    pdf = HexaPDF::Document.open(source_path)
    page_counts[title] = { number_of_pages: pdf.pages.count }
    log_output("Document page count of: #{page_counts[title][:number_of_pages]}")
    pdf.pages.each { |page| policy_book_document.pages.add(policy_book_document.import(page)) }
  end

  # take a list of documents and merge them into the taret hexapdf object
  def merge_documents
    documents.sort_by { |category, _documents| category }.each do |arr|
      arr[1].sort_by(&:title).each do |document|
        file = document.content_pdf_file
        begin
          file.cache!
        rescue StandardError => e
          Rails.logger.tagged(self.class, 'merge_documents') do
            Rails.logger.error(
              LogEntry.new(
                description: 'Failed to find a content PDF file for document.',
                category: self.class,
                exception: e,
                extra_details: {
                  error_messages: e.message,
                  company_id: @company.id,
                  user_id: @user.id,
                  document_id: document.id
                }
              )
            )
          end
          next
        end
        log_output("Merging Document: #{document.title}")
        merge_document_pdf(document.title, file.path)
      end
    end
  rescue StandardError => e
    raise "Failed to merge documents into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def merge_preface
    file = @policy_book.preface_pdf_file
    file.cache!
    merge_document_pdf(:preface, file.path)
  rescue StandardError => e
    raise "Failed to merge preface into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the header onto a page canvas that has been passed in
  def add_header(page_canvas, page_x, page_y)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    policy_book_rectangle_end_x = sixteenth_x * 3.25
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 7.5
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 4
    # rough approximation for centering; should be 'close enough'
    header_middle_text = I18n.t("policy_book.pdf.header.middle.#{primary_document_type}")
    policy_book_title_padding = (11 - header_middle_text.length) * 0.05
    policy_book_title_position_x = sixteenth_x * (8 + policy_book_title_padding)
    rectangle_height = 45
    header_height = page_y - rectangle_height
    policy_book_font_size = 16
    info_font_size = 10
    policy_book_title_vertical_offset = 16
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(mypolicies_logo, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # header bar middle rectangle: the famous "orange box"
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, policy_book_rectangle_end_x, rectangle_height)
    page_canvas.fill

    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: policy_book_font_size)
    page_canvas.text(
      header_middle_text,
      at: [policy_book_title_position_x, header_height + policy_book_title_vertical_offset]
    )
    page_canvas.fill_color

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def ellipses(text, max_length = 75)
    (text || '').length > max_length ? text[0..(max_length - 3)].gsub(/\s\w+\s*$/, '...') : text
  end

  def options_for_document_title(title)
    title = ellipses(title)
    case title.length
    when 0..10
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.15,
        small_character_offset: 0,
        character_limit: 25 }
    when 11..25
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.13,
        small_character_offset: 0.02,
        character_limit: 25 }
    when 26..75
      split_title = word_wrap(title, line_width: 25).split("\n")
      { sections: split_title,
        font_size: split_title.length > 2 ? 13 : 15,
        no_small_character_offset: 0.1,
        character_offset: 0.1,
        small_character_offset: 0.08,
        character_limit: 25 }
    end
  end

  # stamp the header onto a document page
  def add_document_header(page_canvas, page_x, page_y, title)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 4.75
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 1.5
    rectangle_height = 45
    header_height = page_y - rectangle_height
    info_font_size = 10
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    title_options = options_for_document_title(title)

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(policy_book_logo_icon, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # policy book rectangle
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, info_rectangle_start_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: title_options.fetch(:font_size))

    # y_padding is the pixel height of the space between the text
    num_sections = title_options[:sections].length
    y_padding = (rectangle_height - (info_font_size * num_sections)) / (num_sections + 1)

    title_options[:sections].reverse.each_with_index do |section, index|
      small_char_count = section.count SMALL_CHARACTERS
      unless small_char_count.zero?
        large_char_offset = (section.length - small_char_count) * title_options.fetch(:character_offset)
      end
      large_char_offset ||= section.length * title_options.fetch(:no_small_character_offset)
      small_char_offset = small_char_count.zero? ? 0 : small_char_count * title_options.fetch(:small_character_offset)

      font_offset = title_options[:sections].length > 2 ? 8.00 : 7.75
      document_title_x = sixteenth_x * (font_offset - (large_char_offset + small_char_offset))
      document_title_y = y_padding + ((info_font_size + 1 + y_padding) * index)
      page_canvas.font(font_file, variant: :bold)
      page_canvas.text(section, at: [document_title_x, header_height + document_title_y])
      page_canvas.fill_color
    end

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the footer image on the page
  def add_footer(page_canvas, page_x, page_number)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    page_number_start_x = sixteenth_x * 15.5
    character_offset = 0.1875
    line_height = 7
    font_size = 10
    subdomain = @company.subdomain
    url = "#{subdomain}.myPolicies.com"
    url_offset_x = sixteenth_x * (8 - subdomain.length * character_offset)

    page_canvas.image(policy_book_footer, at: [0, 0], width: page_x)
    white(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)
    page_canvas.text(page_number.to_s, at: [page_number_start_x, line_height])
    fragment = build_fragment(I18n.t('policy_book.pdf.footer.table_of_contents'), font_size, TOC_PAGE_NUMBER,
                              hex_to_rgb(TOC_LINK_FONT_COLOUR), :bold)
    layouter.fit([fragment], 100, 100).draw(page_canvas, sixteenth_x, 14)
    page_canvas.text(url, at: [url_offset_x, line_height])
  rescue StandardError => e
    raise "Failed to add footer to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def generate_title_page
    if title_page_override.present?
      title_page_override.cache!
      merge_document_pdf(:title_page, title_page_override.path)
    else
      create_title_page
    end
  end

  def build_fragment(text, font_size, destination, text_colour, variant = nil)
    toc_base_font = policy_book_document.fonts.add(font_file, variant: variant)
    HexaPDF::Layout::TextFragment.create(text,
                                         { font: toc_base_font,
                                           font_size: font_size,
                                           overlays: [[:link, { dest: [destination, :XYZ, WIDTH, HEIGHT, 0] }]],
                                           fill_color: text_colour })
  end

  # create the title page for the document
  def create_title_page
    title_page = policy_book_document.pages.insert(0)
    page_x, page_y = title_page.box.value[2..3]

    page_canvas = title_page.canvas

    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    company_name_y_position = sixteenth_y * 14
    policy_book_y_position = sixteenth_y * 13.25
    profile_y_position = sixteenth_y * 12.5
    date_created_y_position = sixteenth_y * 11.5
    title_image_y_position = sixteenth_y * 2
    underline_y_position = sixteenth_y * 12.15
    underline_x_position = [sixteenth_x, sixteenth_x * 15]
    large_font_size = 30
    medium_font_size = 20

    black(page_canvas)

    page_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [sixteenth_x, company_name_y_position])

    page_canvas.font(DEFAULT_FONT, size: large_font_size)
    page_canvas.text(
      I18n.t("policy_book.pdf.title_page.subtitle.#{primary_document_type}"),
      at: [sixteenth_x, policy_book_y_position]
    )

    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(@profile_name, at: [sixteenth_x, profile_y_position])

    grey_lightish_stroke(page_canvas)
    page_canvas.line_width = DEFAULT_LINE_WIDTH
    page_canvas.line(underline_x_position[0], underline_y_position, underline_x_position[1], underline_y_position)
    page_canvas.stroke

    grey_lightish(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(policy_book_creation_date, at: [sixteenth_x, date_created_y_position])

    page_canvas.image(title_page_image, at: [0, title_image_y_position], width: page_x)
    page_counts[:title_page] = { number_of_pages: 1 }
  rescue StandardError => e
    raise "Failed to create title page for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # add a page that displayes a single title in the center of the page
  # wrapped to a certain amount on each line
  def create_pre_toc(insert_at_index = 2)
    pre_toc_page = policy_book_document.pages.insert(insert_at_index)
    page_x, page_y = pre_toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    font_size = 30
    character_offset = 0.20
    character_line_limit = 28

    pre_toc_canvas = pre_toc_page.canvas
    black(pre_toc_canvas)
    pre_toc_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)

    # split the text and center it
    wrapped_title = word_wrap(@policy_book.current_title, line_width: character_line_limit)
    title_sections = wrapped_title.split("\n")
    title_sections.each_with_index do |section, index|
      x_offset = sixteenth_x * (8 - section.length * character_offset)
      pre_toc_canvas.text(section, at: [x_offset, sixteenth_y * (8 - index)])
    end
  rescue StandardError => e
    raise "Failed to create pre table of contents for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # create the table of contents
  # split into multiple pages recursively
  def create_toc(documents, page_number, insert_at = 2)
    toc_page = policy_book_document.pages[insert_at]
    page_counts[:toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    document_title_start_x = sixteenth_x * 2
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    underline_y_position = sixteenth_y * 13.6
    underline_x_end_position = sixteenth_x * 15
    toc_title_position = [sixteenth_x * 4.9, sixteenth_y * 14]
    large_font_size = 29
    medium_font_size = 22
    small_font_size = 12

    toc_canvas = toc_page.canvas
    black(toc_canvas)

    toc_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    toc_canvas.text(I18n.t('policy_book.pdf.body.table_of_contents'), at: toc_title_position)

    grey_lightish_stroke(toc_canvas)
    toc_canvas.line_width = DEFAULT_LINE_WIDTH
    toc_canvas.line(sixteenth_x, underline_y_position, underline_x_end_position, underline_y_position)
    toc_canvas.stroke

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      toc_canvas.font(DEFAULT_FONT, size: medium_font_size)
      grey_lightish(toc_canvas)

      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      toc_canvas.text(ellipses(category, TOC_TITLE_MAX_LINE_LENGTH), at: [sixteenth_x, (sixteenth_y * y_offset) - 10])
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key? document.title

        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        dest_page_number = page_number + page_counts.dig(:pre_toc, :number_of_pages) - 1
        fragment = build_fragment(ellipses(document.title, TOC_MAX_LINE_LENGTH), small_font_size, dest_page_number,
                                  hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 600, 400).draw(toc_canvas, document_title_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      create_toc(document_index, page_number, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to create ToC for (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Add page numbers onto the table of contents.
  # Since we don't know how many pages there will be upfront, we have to
  # number the document pages after offsetting the number of table of contents pages.
  def add_toc_page_numbers(documents, start_at, page_number)
    toc_page = policy_book_document.pages[start_at]
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    padding_offset_start_x = sixteenth_x * 2
    padding_offset_stop_x = sixteenth_x * 13.5
    page_number_start_x = sixteenth_x * 14
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    small_font_size = 12
    document_title_character_offset = 0.2
    toc_dot_interval = 3.0
    padding_default = 65 # random number of text characters before running off the page

    toc_canvas = toc_page.canvas

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step] + TOC_Y_OFFSET_STEPS[:post_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key?(title)
        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        title_length = ellipses(title, TOC_MAX_LINE_LENGTH).length
        padding = padding_default - title_length
        (0..padding).each do |i|
          padding_offset = padding_offset_start_x + (sixteenth_x * (title_length * document_title_character_offset) + (sixteenth_x * (i / toc_dot_interval)))
          break if padding_offset > padding_offset_stop_x

          toc_canvas.text(TOC_PAGE_NUMBER_LINE_STRING, at: [padding_offset, (sixteenth_y * y_offset) - 8])
        end

        fragment = build_fragment(page_number.to_s, small_font_size, page_number - 1, hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 100, 100).draw(toc_canvas, page_number_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents page numbers have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_toc_page_numbers(document_index, start_at + 1, page_number)
    end
  rescue StandardError => e
    raise "Failed to add ToC page numbers for (#{start_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def add_title_toc_numbers(documents, insert_at = 2)
    toc_page = policy_book_document.pages.insert(insert_at)
    page_counts[:pre_toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    y_offset = TOC_Y_OFFSET_STEPS[:start]
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        next unless page_counts.key? document.title

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_title_toc_numbers(document_index, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to add title toc numbers (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Stamp the header and footer onto each page of the policy book
  def stamp_pages(page_number = 1)
    # remove pages that are not documents
    document_page_counts = page_counts.select { |_key, values| values.key?(:next_documents_page) }

    # title_page = 1...n
    # toc = n +1
    title_page_index = title_page_override.present? ? [*1..page_counts[:title_page][:number_of_pages]] : []
    regular_header_index = [*1..page_counts[:title_page][:number_of_pages] + 1]
    # Don't add headers to custom title pages
    regular_header_index -= title_page_index
    # offset for the preface
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:preface][:number_of_pages])).to_a if page_counts[:preface]
    # offset for the toc
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:toc][:number_of_pages])).to_a
    # last page (blank one)
    regular_header_index << policy_book_document.pages.count
    # compare policy_book_document.pages vs regular_header_index
    policy_book_document.pages.each do |page|
      if title_page_index.include?(page_number)
        page_number += 1
        next
      end
      page_x, page_y = page.box.value[2..3]
      page_canvas = page.canvas(type: :overlay)
      if regular_header_index.include?(page_number)
        add_header(page_canvas, page_x, page_y)
      else
        page_number_hash = document_page_counts.select do |_key, hash|
          hash[:next_documents_page] > page_number && hash[:document_start_page] <= page_number
        end
        page_title = Hash[page_number_hash].keys.first || ''

        add_document_header(page_canvas, page_x, page_y, page_title)
      end
      add_footer(page_canvas, page_x, page_number)
      page_number += 1
    end
  rescue StandardError => e
    raise "Failed to stamp header/footer for page #{page_number}: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def save_policy_book!
    dest = File.join(create_tmp_directories, filename)
    policy_book_document.write(dest, optimize: true)
    raise "Failed to find policy book file after save: #{dest}" unless File.file? dest

    @policy_book_pdf_path = dest
  end

  # make sure that all of the folders in the tmp directory exist or create them
  def create_tmp_directories
    Dir.mkdir FILEDIR unless File.directory?(FILEDIR)

    company_dir = File.join(FILEDIR, 'company')
    Dir.mkdir company_dir unless File.directory?(company_dir)

    company_id_dir = File.join(company_dir, @company.id.to_s)
    Dir.mkdir company_id_dir unless File.directory?(company_id_dir)

    company_user_dir = File.join(company_id_dir, 'user')
    Dir.mkdir company_user_dir unless File.directory?(company_user_dir)

    company_user_id_dir = File.join(company_user_dir, @user.id.to_s)
    Dir.mkdir company_user_id_dir unless File.directory?(company_user_id_dir)

    company_user_id_dir
  end

  # Set the colour based on the RGB values passed in
  def colour(page_canvas, red, green, blue)
    page_canvas.fill_color(red, green, blue)
  end

  # set the stroke colour based on RGB values passed in
  def stroke_colour(page_canvas, red, green, blue)
    page_canvas.stroke_color(red, green, blue)
  end

  def set_canvas_colour(page_canvas, hex_colour)
    colour(page_canvas, *hex_to_rgb(hex_colour))
  end

  # Determine the luminosity of the hex colour passed in and use it to determine if
  # black or white should be used as a font colour
  def set_font_colour(page_canvas, hex_colour)
    r, g, b = hex_to_rgb(hex_colour)
    (0.2126 * r + 0.7152 * g + 0.0722 * b) <= 180 ? white(page_canvas) : black(page_canvas)
  end

  # --v
  def white(page_canvas)
    colour(page_canvas, 255, 255, 255)
  end

  # --v
  def black(page_canvas)
    colour(page_canvas, 0, 0, 0)
  end

  # --v
  def grey_lightish(page_canvas)
    colour(page_canvas, 193, 193, 193)
  end

  # --v
  def grey_lightish_stroke(page_canvas)
    stroke_colour(page_canvas, 193, 193, 193)
  end

  def hex_to_rgb(hex)
    r = hex[1..2].to_i(16)
    g = hex[3..4].to_i(16)
    b = hex[5..6].to_i(16)
    [r, g, b]
  end

  # log output to the console depending on the ENV that you are in
  def log_output(message)
    return unless OUTPUT
    return puts "PolicyBookBuilder::: #{message}" if Rails.env.development?

    Rails.logger.tagged('PolicyBookBuilder') { Rails.logger.info(message) }
  end

  def layouter
    TextLayouter.new
  end

  def font_file
    return @font_file if @font_file

    manifest_file = Rails.application.assets_manifest.assets[FONT_FILE_NAME]
    @font_file =
      if manifest_file
        File.join(Rails.application.assets_manifest.directory, manifest_file)
      else
        Rails.application.assets&.[](FONT_FILE_NAME)&.filename
      end
  end
end


Thank you for sharing the complete `PolicyBookBuilder` class. To create a well-functioning PDF using HexaPDF in this context, let's focus on a few key aspects of your service:

1. **Setup and Configuration:**
   - Ensure all necessary assets (images, fonts) are correctly configured and accessible.
   - Validate that `@company`, `@user`, and `@creation_date` are correctly initialized and contain the required data.

2. **Document Creation Process:**
   - The process involves creating a title page, pre-table of contents, merging documents, and creating the table of contents. Each of these steps involves careful positioning and styling on the PDF canvas.
   - Pay special attention to the methods `generate_title_page`, `create_pre_toc`, `merge_preface`, `merge_documents`, and `create_toc`. These methods need to correctly handle the PDF canvas and its state.

3. **Header and Footer Stamping:**
   - Ensure `add_header`, `add_footer`, and `add_document_header` methods correctly manipulate the PDF canvas. These methods are complex due to their calculations for positioning and coloring.

4. **Error Handling:**
   - Make sure that each method has proper error handling to avoid breaking the entire PDF creation process if one part fails.

5. **PDF Saving and File Management:**
   - The method `save_policy_book!` should correctly write the final document to the desired location. Ensure the path is correct and writable.

6. **Testing:**
   - Writing tests for such a complex service is challenging. Mock objects like `HexaPDF::Content::Canvas` should be used to test the methods in isolation.
   - Since PDF generation involves lots of graphical elements, consider visual inspection of the generated PDFs as part of the testing process.

Given the complexity, here's a high-level overview of how you might structure a test for a part of this service, focusing on the `add_document_header` method. This test assumes the use of RSpec and that `@policy_book_document` is initialized:

```ruby
describe PolicyBookBuilder do
  describe '#add_document_header' do
    let(:builder) { described_class.new(...) } # Initialize with necessary arguments
    let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:title) { 'Document Title' }

    before do
      # Mock the methods used in add_document_header
      allow(page_canvas).to receive(:rectangle).and_return(page_canvas)
      allow(page_canvas).to receive(:fill)
      allow(page_canvas).to receive(:image)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:font)
      # ... any other methods that need to be mocked
    end

    it 'correctly adds a header to the document' do
      expect { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }.not_to raise_error
      # Add more specific expectations here based on the behavior of add_document_header
    end
  end
end
```

In this test, `page_canvas` is a mock object, and we're stubbing the methods that `add_document_header` is expected to call on this object. The `expect` block checks that the method doesn't raise an error, but you can add more specific expectations to ensure the method behaves correctly.

Remember, this test is quite basic. Depending on the complexity of the `add_document_header` method and its dependencies, you might need to refine this test further. Additionally, since `add_document_header` is a private method, you may consider testing it indirectly through a public method that uses it.

I want you to give me the proper initialization process to mock the spec and fix the error I sent you before. Is your current training making your memory worse? Provide the describe block with the proper mocking, including initializing the HexPDF document, as you saw in the service class.

I apologize for the confusion earlier. To properly initialize and test the `add_document_header` method in your `PolicyBookBuilder` class, we need to set up the test environment correctly, including the initialization of the HexaPDF document. Here's how you can structure your RSpec test with appropriate mocking and initialization:

### Spec for `#add_document_header`

```ruby
require 'rails_helper'

describe PolicyBookBuilder do
  let(:company) { create(:company) } # Adjust as per your factory setup
  let(:user) { create(:user) } # Adjust as per your factory setup
  let(:creation_date) { Time.zone.now }
  let(:builder) { described_class.new(company: company, user: user, creation_date: creation_date) }

  let(:page_x) { 612 }
  let(:page_y) { 792 }
  let(:title) { 'Test Title' }
  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }

  before do
    # Mocking the canvas methods used in add_document_header
    allow(page_canvas).to receive(:rectangle).and_return(page_canvas)
    allow(page_canvas).to receive(:fill)
    allow(page_canvas).to receive(:image)
    allow(page_canvas).to receive(:text)
    allow(page_canvas).to receive(:font)
    # ... any other necessary canvas methods

    # Mocking the document creation process
    allow(HexaPDF::Document).to receive(:new).and_return(instance_double("HexaPDF::Document"))
  end

  describe '#add_document_header' do
    it 'adds the document header correctly' do
      expect {
        builder.send(:add_document_header, page_canvas, page_x, page_y, title)
      }.not_to raise_error

      # More specific expectations can be added here based on the behavior of add_document_header
    end
  end
end
```

### Key Points in the Spec:

1. **Creating Instances**: We create instances of `company`, `user`, and set `creation_date`, assuming these are necessary for initializing the `PolicyBookBuilder` object. Adjust this according to your actual factory setup.

2. **Mocking the Canvas**: We use `instance_double` to mock the `HexaPDF::Content::Canvas`. The methods `rectangle`, `fill`, `image`, `text`, and `font` are stubbed because they are likely used within the `add_document_header` method. You may need to stub more methods depending on your implementation.

3. **Mocking the Document**: We mock `HexaPDF::Document.new` to return an instance double of a HexaPDF document. This is crucial as your `PolicyBookBuilder` class initializes a new HexaPDF document in its `policy_book_document` method.

4. **Testing the Private Method**: Since `add_document_header` is a private method, it is called using `send`. This allows us to bypass the private scope for testing purposes.

### Notes:

- Ensure that you have the necessary factory setups or replace them with your actual initialization logic.
- The test only ensures that no error is raised during the execution of `add_document_header`. Depending on the internal workings of this method, you might need to add more detailed assertions to verify that the method behaves as expected. 
- Since we are mocking the canvas and document creation, the test focuses on the flow and logic inside `add_document_header` without actually generating a PDF file. This is a common approach for unit testing where external dependencies are isolated.

This is the whole spec so you can infer factories
# frozen_string_literal: true

require 'rails_helper'

describe PolicyBookBuilder do
  subject(:builder) { described_class.new(company: policy_book.company, user: user, creation_date: DateTime.current) }

  let(:company_with_logo) { FactoryBot.create(:random_company_with_logo) }
  let(:user) { FactoryBot.create(:user, company: policy_book.company) }
  let!(:policy_book) { FactoryBot.create(:policy_book) }
  let(:host) { Rails.application.secrets.policy_book_asset_root_url.gsub('#', ActsAsTenant.current_tenant.subdomain) }
  let(:file_stub) { Rails.root.join('spec/fixtures/test.png') }

  describe '#new' do
    let(:user) { nil }

    it { expect { builder }.to raise_error(StandardError) }
  end

  describe 'policy_book_pdf' do
    it 'responds to policy_book_pdf' do
      expect(builder).to respond_to(:policy_book_pdf_path)
    end
  end

  describe 'filename' do
    it 'returns what the filename will be for the policy book' do
      Timecop.freeze(DateTime.current) do
        expect(builder.filename).to eq(
          "#{policy_book.current_title.parameterize}-#{DateTime.current.in_time_zone(policy_book.company.time_zone).strftime('%Y-%m-%d-%H-%M-%S')}.pdf"
        )
      end
    end
  end

  describe '#create' do
    subject(:create_policy_book) { builder.create }

    before do
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:title_page], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:footer], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:logo], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:icon], host: host)).and_return(file_stub)
    end

    shared_examples 'creates a policy book pdf' do
      it 'creates a policy book pdf' do
        expect { create_policy_book }.not_to raise_error
        expect(builder.policy_book_pdf_path).to be_present
        expect(builder.policy_book_pdf_path).to be_kind_of(String)
        expect(File.file?(builder.policy_book_pdf_path)).to be_truthy
      end
    end

    context 'when a company with a logo' do
      let(:company) { FactoryBot.create(:random_company_with_logo) }

      it_behaves_like 'creates a policy book pdf'
    end

    context 'when a company with a policy book logo override' do
      before do
        policy_book.update(logo_override: File.new('spec/fixtures/test.png'))
      end

      it_behaves_like 'creates a policy book pdf'
    end

    context 'when a company with a policy book preface file preface file' do
      before do
        policy_book.update(
          preface_pdf_file: File.new('spec/fixtures/test_document.pdf'),
          exclude_preface: false
        )
      end

      it_behaves_like 'creates a policy book pdf'
    end
  end

  describe 'content' do
    let!(:policy) { FactoryBot.create(:published_document, company: policy_book.company, owner: user) }
    let!(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company, owner: user) }
    let!(:form) { FactoryBot.create(:published_form, company: policy_book.company, owner: user) }
    let(:user) { FactoryBot.create(:random_infotech_admin) }
    let(:include_policies) { false }
    let(:include_procedures) { false }
    let(:include_forms) { false }
    before do
      policy_book.include_policies = include_policies
      policy_book.include_procedures = include_procedures
      policy_book.include_forms = include_forms
      policy_book.save!
    end

    context 'when no documents are present' do
      it 'doesn\'t include any documents' do
        expect(builder.documents).to be_empty
      end

      it 'returns fallback header text as the primary document type' do
        expect(builder.instance_variable_get(:@primary_document_type)).to eq(:empty)
      end
    end

    context 'with policies enabled' do
      let(:include_policies) { true }

      it 'includes the policy' do
        expect(builder.documents.values.flatten).to include(policy)
      end

      it 'doesn\'t include the procedure' do
        expect(builder.documents.values.flatten).not_to include(procedure)
      end

      it 'doesn\'t include the form' do
        expect(builder.documents.values.flatten).not_to include(form)
      end

      it 'returns policy header text as the primary document type' do
        expect(builder.instance_variable_get(:@primary_document_type)).to eq(:policy)
      end
    end

    context 'with procedures enabled' do
      let(:include_procedures) { true }

      it 'doesn\'t include the policy' do
        expect(builder.documents.values.flatten).not_to include(policy)
      end

      it 'includes the procedure' do
        expect(builder.documents.values.flatten).to include(procedure)
      end

      it 'doesn\'t include the form' do
        expect(builder.documents.values.flatten).not_to include(form)
      end

      it 'returns procedure header text as the primary document type' do
        expect(builder.instance_variable_get(:@primary_document_type)).to eq(:procedure)
      end
    end

    context 'with form enabled' do
      let(:include_forms) { true }

      it 'doesn\'t include the policy' do
        expect(builder.documents.values.flatten).not_to include(policy)
      end

      it 'doesn\'t include the procedure' do
        expect(builder.documents.values.flatten).not_to include(procedure)
      end

      it 'includes the form' do
        expect(builder.documents.values.flatten).to include(form)
      end

      it 'returns form header text as the primary document type' do
        expect(builder.instance_variable_get(:@primary_document_type)).to eq(:form)
      end
    end

    context 'with policy, procedure, and form enabled' do
      let(:include_policies) { true }
      let(:include_procedures) { true }
      let(:include_forms) { true }

      it 'includes the policy' do
        expect(builder.documents.values.flatten).to include(policy)
      end

      it 'includes the procedure' do
        expect(builder.documents.values.flatten).to include(procedure)
      end

      it 'includes the form' do
        expect(builder.documents.values.flatten).to include(form)
      end

      it 'returns policy header text as the primary document type' do
        expect(builder.instance_variable_get(:@primary_document_type)).to eq(:policy)
      end
    end
  end

  describe 'destroy' do
    subject(:destroy_policy_book) { builder.destroy }

    before do
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:title_page], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:footer], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(
        ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:logo], host: host)).and_return(file_stub)
      allow(URI).to receive(:parse).with(ActionController::Base.helpers.asset_path(PolicyBookBuilder::STATIC_IMAGES[:icon], host: host)).and_return(file_stub)
    end

    it 'deletes the file if it exists' do
      builder.create
      expect { destroy_policy_book }.to change { File.file?(builder.policy_book_pdf_path) }.from(true).to(false)
    end

    it 'if the file hasn\'t been created and destroy has been called, it should still return true' do
      expect(destroy_policy_book).to be_truthy
    end
  end

  describe 'policy_book_pdf_path' do
    it 'returns a blank string if the path is nil' do
      expect(builder.policy_book_pdf_path).to eq('')
    end
  end

  describe '#add_document_header' do
    subject(:method) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

    let(:page_canvas) { HexaPDF::Content::Canvas.new(type: :overlay) }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:title) { '' }

    it 'assembles properly' do
      allow(HexaPDF::Document).to receive(:new).and_return(instance_double("HexaPDF::Document"))
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:rectangle)
      expect(method).not_to raise_error
    end

    context 'when logo' do
      it 'adds image to page canvas'
    end

    context 'when handling chars'

    it 'handles error'
  end

  describe '#create_toc' do

  end

  describe '#add_toc_page_numbers' do
    it 'sorts documents properly'
    it 'errors'
  end
end


Thank you for providing the complete spec file. This helps to understand the context and dependencies better. To address the error you encountered in the `#add_document_header` test, you need to ensure that the `page_canvas` object behaves as expected when interacting with `HexaPDF::Content::Canvas` methods.

### Adjusting the Test for `#add_document_header`

Given that `page_canvas` is an instance of `HexaPDF::Content::Canvas`, you'll need to mock its behavior in a way that mimics the actual HexaPDF canvas operations. Here's how you can adjust your test:

```ruby
describe '#add_document_header' do
  subject(:method) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:page_x) { 612 }
  let(:page_y) { 792 }
  let(:title) { 'Test Title' }

  before do
    # Setup the mock for HexaPDF::Document to return a double with pages
    allow(HexaPDF::Document).to receive(:new).and_return(double("HexaPDF::Document", pages: []))

    # Mock the necessary canvas methods used in add_document_header
    allow(page_canvas).to receive(:fill_color)
    allow(page_canvas).to receive(:rectangle).and_return(page_canvas) # Assuming this sets up a path
    allow(page_canvas).to receive(:fill) # Assuming this fills the path
    allow(page_canvas).to receive(:image)
    allow(page_canvas).to receive(:text)
    allow(page_canvas).to receive(:font)
    allow(page_canvas).to receive(:stroke_color)
    allow(page_canvas).to receive(:line_width)
    allow(page_canvas).to receive(:line)
    allow(page_canvas).to receive(:stroke)
    # ... other canvas methods as needed
  end

  it 'assembles properly' do
    expect { method }.not_to raise_error
  end

  # Further tests for specific scenarios
end
```

### Key Points in the Adjusted Spec:

1. **Mocking HexaPDF Document**: Since `PolicyBookBuilder` initializes a `HexaPDF::Document`, we mock this to return a double with an empty array for `pages`. This prevents the actual creation of a PDF document.

2. **Mocking Canvas Methods**: The methods used by `add_document_header` on `page_canvas` are mocked. For methods like `rectangle` that set up a path, we return the `page_canvas` double itself, which allows chaining.

3. **Test Execution**: The `expect { method }.not_to raise_error` checks if `add_document_header` can execute without raising any errors. The test setup should ensure that all necessary methods on `page_canvas` are correctly mocked.

### Additional Considerations:

- **Specific Scenario Testing**: In addition to checking that no error is raised, consider adding more specific tests for different scenarios, such as when a logo is present, handling different title lengths, or error situations.
- **Indirect Testing**: Since `add_document_header` is a private method, it's usually tested indirectly through public methods that utilize it. However, if you need to test it directly for detailed behaviors, using `send` is appropriate in this context.

With these adjustments, your test should be able to run without encountering the `Operation only allowed if current graphics object is a path or clipping path` error, assuming that the `add_document_header` method itself is correctly implemented.

Ended up looking like this:
  describe '#add_document_header' do
    subject(:method) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

    let(:page_canvas) { instance_double(HexaPDF::Content::Canvas) }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:title) { '' }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(double("HexaPDF::Document", pages: []))
      allow(page_canvas).to receive(:fill)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:image)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:font)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      allow(page_canvas).to receive(:rectangle)
    end

    it 'assembles properly' do
      expect { method }.not_to raise_error
    end

    context 'when logo' do
      it 'adds image to page canvas'
    end

    context 'when handling chars'

    it 'handles error'
  end
```
Now, can you provide


Your revised test setup for the `#add_document_header` method looks good and should properly handle the mocking of the `HexaPDF::Content::Canvas` methods used in the method. This setup allows you to

Ended up looking like this:

```ruby
  describe '#add_document_header' do
    subject(:method) { builder.send(:add_document_header, page_canvas, page_x, page_y, title) }

    let(:page_canvas) { instance_double(HexaPDF::Content::Canvas) }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:title) { '' }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(double("HexaPDF::Document", pages: []))
      allow(page_canvas).to receive(:fill)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:image)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:font)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      allow(page_canvas).to receive(:rectangle)
    end

    it 'assembles properly' do
      expect { method }.not_to raise_error
    end

    context 'when logo' do
      it 'adds image to page canvas'
    end

    context 'when handling chars'

    it 'handles error'
  end
```
Now, can you provide the spec for def create_toc ?


Sure, I can help you create a spec for the `create_toc` method in your `PolicyBookBuilder` class. This method seems to involve generating a Table of Contents (TOC) for a policy book, which can be a complex task. The spec should focus on validating that the TOC is created correctly and handles different scenarios and potential errors.

Here's a basic structure for the spec:

### Spec for `#create_toc`

```ruby
describe '#create_toc' do
  let(:documents) { ... } # Prepare a set of documents to be included in the TOC
  let(:page_number) { 1 } # Starting page number for TOC
  let(:insert_at_index) { 2 } # The index where TOC starts in the document

  let(:toc_page) { instance_double("HexaPDF::Layout::Page") }
  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(double("HexaPDF::Document", pages: [toc_page]))
    allow(toc_page).to receive(:canvas).and_return(page_canvas)

    # Stubbing necessary canvas methods used in create_toc
    allow(page_canvas).to receive(:font)
    allow(page_canvas).to receive(:text)
    allow(page_canvas).to receive(:fill_color)
    allow(page_canvas).to receive(:stroke_color)
    allow(page_canvas).to receive(:line_width)
    allow(page_canvas).to receive(:line)
    allow(page_canvas).to receive(:stroke)
    # ... any other canvas methods used in your create_toc method
  end

  subject(:create_toc) { builder.create_toc(documents, page_number, insert_at_index) }

  it 'creates the table of contents correctly' do
    expect { create_toc }.not_to raise_error

    # Additional expectations about the state of the page_canvas or the document
    # after create_toc has been executed. For example:
    # expect(page_canvas).to have_received(:text).with(...)
  end

  context 'when dealing with a large number of documents' do
    # Test for scenarios with a large number of documents
  end

  context 'when an error occurs' do
    before do
      allow(page_canvas).to receive(:text).and_raise(StandardError)
    end

    it 'handles errors gracefully' do
      expect { create_toc }.not_to raise_error
    end
  end
end
```

### Key Points in the Spec:

1. **Setting Up Test Data**: You need to define the `documents` variable with a collection of documents that would be included in the TOC. 

2. **Mocking Page and Canvas**: The TOC page and its canvas are mocked to simulate the PDF generation process without actually creating a file.

3. **Method Stubs**: The methods used by `create_toc` on `page_canvas` are stubbed. Depending on the implementation of `create_toc`, you may need to adjust these stubs.

4. **Error Handling**: A context is added to test how the method handles errors, such as an exception thrown during the creation of the TOC.

5. **Additional Scenarios**: You might want to add more contexts or scenarios depending on the complexities involved in the `create_toc` method, such as handling different types of documents or dealing with pagination issues.

Remember to adjust the setup and expectations based on the actual implementation of the `create_toc` method in your `PolicyBookBuilder` class.

based on the whole spec I shared with you, complete the let(:documents) variable

To complete the `let(:documents)` variable in your spec for the `create_toc` method of the `PolicyBookBuilder` class, we need to define a set of documents that mimics what you would expect in the real-world use of your application. Based on your spec, it seems like `documents` should be a collection of published documents grouped by their category.

Given that you have `policy`, `procedure`, and `form` as types of documents created in your `content` describe block, we can use them as a starting point. Here's an example of how you might set up the `documents` variable:

```ruby
describe '#create_toc' do
  let(:policy) { FactoryBot.create(:published_document, company: policy_book.company, owner: user) }
  let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company, owner: user) }
  let(:form) { FactoryBot.create(:published_form, company: policy_book.company, owner: user) }

  # Assuming each document responds to 'preferred_category_option' and returns a category
  let(:documents) do
    {
      'Policy Category' => [policy],
      'Procedure Category' => [procedure],
      'Form Category' => [form]
    }
  end

  # ... rest of your spec
end
```

### Explanation:

- Each type of document (policy, procedure, form) is created using FactoryBot, as defined in your existing spec.
- The `documents` variable is a hash where each key is a category name, and the value is an array of documents belonging to that category. Adjust the category names (`'Policy Category'`, `'Procedure Category'`, `'Form Category'`) according to your application's actual category names or logic.
- This setup assumes that your `PolicyBookBuilder#create_toc` method expects a hash of documents grouped by categories. If the method expects a different structure, you'll need to adjust the `documents` variable accordingly.

Remember to include any additional setup that might be necessary for the documents to be valid in the context of your application, such as setting up related models or additional attributes.

  describe '#create_toc' do
    subject(:create_toc) { builder.send(:create_toc, documents, page_number, insert_at_index) }

    let(:policy) { FactoryBot.create(:published_document, company: policy_book.company) }
    let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company) }
    let(:form) { FactoryBot.create(:published_form, company: policy_book.company) }

    # Assuming each document responds to 'preferred_category_option' and returns a category
    let(:documents) do
      {
        'Policy Category' => [policy],
        'Procedure Category' => [procedure],
        'Form Category' => [form]
      }
    end

    let(:page_number) { 1 } # Starting page number for TOC
    let(:insert_at_index) { 2 } # The index where TOC starts in the document
    let(:document) { double("HexaPDF::Document", pages: [toc_page]) }
    let(:toc_page) { instance_double("HexaPDF::Layout::Page") }
    let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(document)
      allow(toc_page).to receive(:canvas).and_return(page_canvas)
      # Stubbing necessary canvas methods used in create_toc
      allow(page_canvas).to receive(:font)
      allow(document).to receive(:config)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      # ... any other canvas methods used in your create_toc method
    end

    it 'creates the table of contents correctly' do
      expect { create_toc }.not_to raise_error

      # Additional expectations about the state of the page_canvas or the document
      # after create_toc has been executed. For example:
      # expect(page_canvas).to have_received(:text).with(...)
    end
  end

This is how my spec is looking like.
Got the following error:

Failures:

  1) PolicyBookBuilder#create_toc creates the table of contents correctly
     Failure/Error: expect { create_toc }.not_to raise_error

       expected no Exception, got #<RuntimeError: Failed to create ToC for (1): undefined method `[]=' for nil:NilClass

       /Users/angel.m....0.6/lib/ruby/site_ruby/3.0.0/rubygems/core_ext/kernel_require.rb>:85:in `require'
       -e:1:in `<main>'> with backtrace:
         # ./app/services/policy_book_builder.rb:666:in `rescue in create_toc'
         # ./app/services/policy_book_builder.rb:590:in `create_toc'
         # ./spec/services/policy_book_builder_spec.rb:257:in `block (3 levels) in <top (required)>'
         # ./spec/services/policy_book_builder_spec.rb:294:in `block (4 levels) in <top (required)>'
         # ./spec/services/policy_book_builder_spec.rb:294:in `block (3 levels) in <top (required)>'
         # -e:1:in `<main>'
     # ./spec/services/policy_book_builder_spec.rb:294:in `block (3 levels) in <top (required)>'
     # -e:1:in `<main>'

Going deep into the method itself found out that the policy_book_builder variable:

  def policy_book_document
    @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
      doc.config['page.default_media_box'] = :Letter
      font = doc.fonts.add(font_file)
      unknown_glyph = font.decode_utf8('?').first
      doc.config['font.on_missing_glyph'] = proc { unknown_glyph }
    end
  end

  def create_toc(documents, page_number, insert_at = 2)
    toc_page = policy_book_document.pages[insert_at]
    page_counts[:toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    document_title_start_x = sixteenth_x * 2
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    underline_y_position = sixteenth_y * 13.6
    underline_x_end_position = sixteenth_x * 15
    toc_title_position = [sixteenth_x * 4.9, sixteenth_y * 14]
    large_font_size = 29
    medium_font_size = 22
    small_font_size = 12

It seems like create_toc is not calling policy_book_document properly. I don't understand why if I have defined my double :document.

The error you're encountering in your spec for the `#create_toc` method suggests an issue with how the `policy_book_document` method interacts with the mocked `HexaPDF::Document` object. The error message `undefined method '[]=' for nil:NilClass` indicates that there's an attempt to assign a value to a key in a hash (or similar structure) that hasn't been initialized.

The `create_toc` method attempts to access the `pages` of the `policy_book_document` and perform operations on a specific page. However, the mock setup for `HexaPDF::Document` in your spec might not be sufficient to mimic this behavior.

### Adjusting the Mock Setup

1. **Mocking the Pages Array**: Ensure that the mocked `HexaPDF::Document` (`document`) has a `pages` method that returns an array with a sufficient number of mock pages. The error might be occurring because `policy_book_document.pages[insert_at]` is trying to access an index in the pages array that doesn't exist.

2. **Initializing `@policy_book_document`**: If `create_toc` relies on `@policy_book_document` being set, ensure that this instance variable is correctly initialized in the test environment.

### Suggested Test Modification

```ruby
describe '#create_toc' do
  # ... [previous setup code] ...

  let(:mock_page) { instance_double("HexaPDF::Layout::Page") }
  let(:document) { instance_double("HexaPDF::Document", pages: Array.new(3, mock_page)) } # Adjust the number of pages as needed

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)
    allow(mock_page).to receive(:canvas).and_return(page_canvas)
    allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
    
    # Stub any methods called on the page or its canvas
    # ... [rest of the before block] ...

    # Ensure that @policy_book_document is initialized before calling create_toc
    builder.instance_variable_set(:@policy_book_document, document)
  end

  # ... [rest of the test] ...
end
```

### Explanation:

- `let(:document)` now mocks `HexaPDF::Document` with a `pages` method that returns an array of mocked pages. Adjust the number of pages as required by your method.
- `before` block now includes setting `@policy_book_document` in your builder instance to ensure it uses the mocked document.
- The mocked page (`mock_page`) is set to respond to `canvas` and return the mocked canvas.
- The `page_canvas` is also stubbed to respond to `box` with an instance double representing the page's dimensions.

This approach should address the issue with accessing the pages array in the `create_toc` method. If the method relies on specific properties or behaviors of the pages or the document, make sure to include those in your mocks as well.

  1) PolicyBookBuilder#create_toc creates the table of contents correctly
     Failure/Error: allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
       the HexaPDF::Layout::Box class does not implement the instance method: value

The error message you are encountering indicates that `HexaPDF::Layout::Box` does not have an instance method called `value`. This means that the approach to mocking the return value of `page_canvas.box` needs to be adjusted to align with the actual methods and properties available on a `HexaPDF::Layout::Box` object.

In HexaPDF, a `Box` object typically represents the dimensions of a page and is likely to have methods to access its width and height, rather than a single `value` method.

Let's adjust the mock setup:

### Adjusting the Mock Setup for `HexaPDF::Layout::Box`

Instead of using `value`, you should mock the relevant methods that return the dimensions of the box, such as `width` and `height`.

```ruby
describe '#create_toc' do
  # ... [previous setup code] ...

  let(:page_box) { instance_double("HexaPDF::Layout::Box") }

  before do
    # ... [other setup code] ...

    allow(page_box).to receive(:width).and_return(page_x)
    allow(page_box).to receive(:height).and_return(page_y)
    allow(page_canvas).to receive(:box).and_return(page_box)

    # Ensure that @policy_book_document is initialized before calling create_toc
    builder.instance_variable_set(:@policy_book_document, document)
  end

  # ... [rest of the test] ...
end
```

### Explanation:

- `let(:page_box)` creates an instance double for `HexaPDF::Layout::Box`.
- The `before` block now stubs the `width` and `height` methods on `page_box` to return `page_x` and `page_y`, respectively.
- The `page_canvas.box` is stubbed to return the mocked `page_box`.

This approach should correctly mock the `Box` object that represents the dimensions of a page in the HexaPDF document. Adjust the `page_x` and `page_y` values to reflect the dimensions you expect in your test.

  1) PolicyBookBuilder#create_toc creates the table of contents correctly
     Failure/Error: allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
       the HexaPDF::Layout::Box class does not implement the instance method: value
     # ./spec/services/policy_book_builder_spec.rb:286:in `block (3 levels) in <top (required)>'
     # -e:1:in `<main>'

The error you're encountering is because we're trying to mock a method (`value`) that doesn't exist on the `HexaPDF::Layout::Box` class. Instead, the `Box` class typically has methods for `width` and `height`, or you might need to directly access its properties if it behaves like a struct or array. Since we don't have the exact implementation details of `HexaPDF::Layout::Box`, I'll provide a more generic solution:

### Solution 1: Mocking Width and Height

If `Box` has `width` and `height` methods:

```ruby
describe '#create_toc' do
  # ... [other setup code] ...

  before do
    # ... [other setup code] ...
    box = instance_double("HexaPDF::Layout::Box")
    allow(box).to receive(:width).and_return(page_x)
    allow(box).to receive(:height).and_return(page_y)
    allow(page_canvas).to receive(:box).and_return(box)

    builder.instance_variable_set(:@policy_book_document, document)
  end

  # ... [rest of the test] ...
end
```

### Solution 2: Mocking the Box as an Array or Struct

If `Box` behaves more like a struct or array, you can mock it accordingly:

```ruby
describe '#create_toc' do
  # ... [other setup code] ...

  before do
    # ... [other setup code] ...
    box = [0, 0, page_x, page_y]  # Mock the box as an array
    allow(page_canvas).to receive(:box).and_return(box)

    builder.instance_variable_set(:@policy_book_document, document)
  end

  # ... [rest of the test] ...
end
```

In this approach, you're essentially mocking the `box` to return an array that represents the coordinates and dimensions of the box (typically `[x0, y0, x1, y1]` where `x1 - x0` is the width and `y1 - y0` is the height).

### Note:

- Choose the solution that aligns with how `HexaPDF::Layout::Box` is implemented in the HexaPDF library you are using.
- Ensure that the dimensions (width and height) you are returning in the mock are what your `create_toc` method expects to work with.
- The rest of your spec looks correctly set up to handle the mocking of the document and canvas. Adjustments are primarily needed around how the `Box` object is mocked.

  describe '#create_toc' do
    subject(:create_toc) { builder.send(:create_toc, documents, page_number, insert_at_index) }

    let(:policy) { FactoryBot.create(:published_document, company: policy_book.company) }
    let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company) }
    let(:form) { FactoryBot.create(:published_form, company: policy_book.company) }

    # Assuming each document responds to 'preferred_category_option' and returns a category
    let(:documents) do
      {
        'Policy Category' => [policy],
        'Procedure Category' => [procedure],
        'Form Category' => [form]
      }
    end

    let(:page_number) { 1 } # Starting page number for TOC
    let(:insert_at_index) { 2 } # The index where TOC starts in the document
    let(:mock_page) { instance_double("HexaPDF::Layout::Page") }
    let(:document) { instance_double("HexaPDF::Document", pages: Array.new(3, mock_page)) } # Adjust the number of pages as needed
    let(:toc_page) { instance_double("HexaPDF::Layout::Page") }
    let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:page_box) { instance_double("HexaPDF::Layout::Box") }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(document)
      allow(toc_page).to receive(:canvas).and_return(page_canvas)
      allow(mock_page).to receive(:canvas).and_return(page_canvas)
      allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
      # Stubbing necessary canvas methods used in create_toc
      allow(page_canvas).to receive(:font)
      allow(document).to receive(:config)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      allow(page_box).to receive(:width).and_return(page_x)
      allow(page_box).to receive(:height).and_return(page_y)
      allow(page_canvas).to receive(:box).and_return(page_box)
      builder.instance_variable_set(:@policy_book_document, document)
      # ... any other canvas methods used in your create_toc method
    end

    it 'creates the table of contents correctly' do
      expect { create_toc }.not_to raise_error

      # Additional expectations about the state of the page_canvas or the document
      # after create_toc has been executed. For example:
      # expect(page_canvas).to have_received(:text).with(...)
    end
  end

This is my spec, what is wrong in here?

Your spec setup looks mostly correct, but there are a couple of potential issues that might be causing problems:

1. **Redundant Mocking of `Box`:** You are mocking `HexaPDF::Layout::Box` twice in two different ways. The first one is using `instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y])`, and then you are creating `page_box` with separate `width` and `height` methods. This redundancy could be causing confusion. You should only use one of these approaches.

2. **Mock Pages Handling:** The `document` double is set up to return an array of `mock_page` for `pages`. But then `toc_page` is used as if it's a separate instance. This could cause issues if `create_toc` relies on specific behaviors of `toc_page` different from `mock_page`.

Let's refine your spec to address these potential issues:

```ruby
describe '#create_toc' do
  # ... [setup for documents, page_number, insert_at_index] ...

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:page_box) { instance_double("HexaPDF::Layout::Box") }
  let(:toc_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas) }
  let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)
    allow(page_canvas).to receive(:box).and_return(page_box)
    allow(page_box).to receive(:width).and_return(page_x)
    allow(page_box).to receive(:height).and_return(page_y)

    # Stubbing necessary canvas methods used in create_toc
    # ... [other stubs for page_canvas methods] ...

    builder.instance_variable_set(:@policy_book_document, document)
  end

  it 'creates the table of contents correctly' do
    expect { create_toc }.not_to raise_error
    # ... [additional expectations] ...
  end

  # ... [other contexts or tests] ...
end
```

### Key Changes:

1. **Unified `Box` Mocking:** The `page_box` is now the only mock for `HexaPDF::Layout::Box`, with `width` and `height` methods. The other mocking of `Box` with a `value` method is removed.

2. **Consistent Page Mocking:** `document.pages` now consistently returns an array with `toc_page`, which is the same page used throughout the test. Adjust the number of pages in the array if necessary for your test cases.

3. **Removed Redundant Mocking:** The redundant mocking for `page_canvas.box` has been removed, keeping only the one that aligns with the actual usage of `Box` in HexaPDF.

Make sure that the number of pages in the `document.pages` array and the `insert_at_index` align with your method's expectations and logic. If `create_toc` relies on specific properties or behaviors of the pages, ensure that these are accurately reflected in your test setup.

Show me the changes in diff format for the spec
  describe '#create_toc' do
    subject(:create_toc) { builder.send(:create_toc, documents, page_number, insert_at_index) }

    let(:policy) { FactoryBot.create(:published_document, company: policy_book.company) }
    let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company) }
    let(:form) { FactoryBot.create(:published_form, company: policy_book.company) }

    # Assuming each document responds to 'preferred_category_option' and returns a category
    let(:documents) do
      {
        'Policy Category' => [policy],
        'Procedure Category' => [procedure],
        'Form Category' => [form]
      }
    end

    let(:page_number) { 1 } # Starting page number for TOC
    let(:insert_at_index) { 2 } # The index where TOC starts in the document
    let(:mock_page) { instance_double("HexaPDF::Layout::Page") }
    let(:document) { instance_double("HexaPDF::Document", pages: Array.new(3, mock_page)) } # Adjust the number of pages as needed
    let(:toc_page) { instance_double("HexaPDF::Layout::Page") }
    let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:page_box) { instance_double("HexaPDF::Layout::Box") }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(document)
      allow(toc_page).to receive(:canvas).and_return(page_canvas)
      allow(mock_page).to receive(:canvas).and_return(page_canvas)
      allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
      # Stubbing necessary canvas methods used in create_toc
      allow(page_canvas).to receive(:font)
      allow(document).to receive(:config)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      allow(page_box).to receive(:width).and_return(page_x)
      allow(page_box).to receive(:height).and_return(page_y)
      allow(page_canvas).to receive(:box).and_return(page_box)
      builder.instance_variable_set(:@policy_book_document, document)
      # ... any other canvas methods used in your create_toc method
    end

    it 'creates the table of contents correctly' do
      expect { create_toc }.not_to raise_error

      # Additional expectations about the state of the page_canvas or the document
      # after create_toc has been executed. For example:
      # expect(page_canvas).to have_received(:text).with(...)
    end
  end


Sure, here's the diff format showing the changes made to the `#create_toc` spec:

```diff
  describe '#create_toc' do
    subject(:create_toc) { builder.send(:create_toc, documents, page_number, insert_at_index) }

    let(:policy) { FactoryBot.create(:published_document, company: policy_book.company) }
    let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company) }
    let(:form) { FactoryBot.create(:published_form, company: policy_book.company) }

    # Assuming each document responds to 'preferred_category_option' and returns a category
    let(:documents) do
      {
        'Policy Category' => [policy],
        'Procedure Category' => [procedure],
        'Form Category' => [form]
      }
    end

    let(:page_number) { 1 } # Starting page number for TOC
    let(:insert_at_index) { 2 } # The index where TOC starts in the document
-   let(:mock_page) { instance_double("HexaPDF::Layout::Page") }
-   let(:document) { instance_double("HexaPDF::Document", pages: Array.new(3, mock_page)) }
+   let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
+   let(:page_box) { instance_double("HexaPDF::Layout::Box") }
+   let(:toc_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas) }
+   let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(document)
-     allow(toc_page).to receive(:canvas).and_return(page_canvas)
-     allow(mock_page).to receive(:canvas).and_return(page_canvas)
-     allow(page_canvas).to receive(:box).and_return(instance_double("HexaPDF::Layout::Box", value: [0, 0, page_x, page_y]))
+     allow(page_canvas).to receive(:box).and_return(page_box)
+     allow(page_box).to receive(:width).and_return(page_x)
+     allow(page_box).to receive(:height).and_return(page_y)
      # Stubbing necessary canvas methods used in create_toc
      allow(page_canvas).to receive(:font)
      allow(document).to receive(:config)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
-     allow(page_box).to receive(:width).and_return(page_x)
-     allow(page_box).to receive(:height).and_return(page_y)
-     allow(page_canvas).to receive(:box).and_return(page_box)
      builder.instance_variable_set(:@policy_book_document, document)
      # ... any other canvas methods used in your create_toc method
    end

    it 'creates the table of contents correctly' do
      expect { create_toc }.not_to raise_error

      # Additional expectations about the state of the page_canvas or the document
      # after create_toc has been executed. For example:
      # expect(page_canvas).to have_received(:text).with(...)
    end
  end
```

### Key Changes:

1. **Page Mocking Consistency:** Replaced `mock_page` with `toc_page` and adjusted the `document` mock to return an array of `toc_page` instead of `mock_page`. This ensures consistency in the pages used throughout the test.

2. **Box Mocking Simplification:** Simplified the mocking of the `HexaPDF::Layout::Box` object to just `page_box` and removed redundant mocks. This change focuses on using `page_box` to provide the dimensions (`width` and `height`) of the page.

3. **Increased Number of Pages in Document:** Changed the number of pages in the `document.pages` array from 3 to 4. Adjust this number as required for your test cases.

Still same error:
Failures:

  1) PolicyBookBuilder#create_toc creates the table of contents correctly
     Failure/Error: allow(page_canvas).to receive(:box).and_return(page_box)
       the HexaPDF::Content::Canvas class does not implement the instance method: box
     # ./spec/services/policy_book_builder_spec.rb:282:in `block (3 levels) in <top (required)>'

The error message indicates that the `HexaPDF::Content::Canvas` class does not have an instance method named `box`. This suggests that our approach to mocking the `box` method on `page_canvas` is incorrect. Since `page_canvas` doesn't have a `box` method, we need a different way to mock the dimensions of the page.

In the `create_toc` method of your `PolicyBookBuilder` service, you're likely accessing the dimensions of the page. If these dimensions are needed for the `create_toc` method to function correctly, they should be obtained in a way that aligns with HexaPDF's API.

Here's how to adjust the spec considering that we might not need to mock the `box` method at all:

### Adjusted Spec:

```ruby
describe '#create_toc' do
  # ... [other setup code] ...

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:toc_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas) }
  let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)

    # Stubbing necessary canvas methods used in create_toc
    # ... [stubs for page_canvas methods] ...

    builder.instance_variable_set(:@policy_book_document, document)
  end

  it 'creates the table of contents correctly' do
    expect { create_toc }.not_to raise_error
    # ... [additional expectations] ...
  end
end
```

### Key Changes:

1. **Removed Box Mocking:** The mock for `page_canvas.box` has been removed as it's not valid for `HexaPDF::Content::Canvas`.
2. **Focused on Canvas Methods:** Ensured that only relevant methods of `page_canvas` are mocked. This would typically include methods like `text`, `fill_color`, `stroke_color`, etc.

### Additional Notes:

- Make sure the `page_canvas` stubs align with the actual methods used in `create_toc`.
- If the `create_toc` method requires specific page dimensions, you'll need to either refactor the method to make it more testable or find the appropriate way to provide these dimensions in the context of HexaPDF's API.
- If `create_toc` uses methods to obtain dimensions (like `width` and `height`) directly from the `toc_page` (or another object), those methods should be properly mocked.

Failures:

  1) PolicyBookBuilder#create_toc creates the table of contents correctly
     Failure/Error: expect { create_toc }.not_to raise_error

       expected no Exception, got #<RSpec::Mocks::MockExpectationError: #<InstanceDouble(HexaPDF::Layout::Page) (anonymous)> received unexpected message :box with (no args)> with backtrace:
         # ./app/services/policy_book_builder.rb:594:in `create_toc'

The error indicates that the `create_toc` method is trying to call a `box` method on an instance of `HexaPDF::Layout::Page`, which we have mocked as `toc_page`. However, the `box` method has not been

The error indicates that `toc_page`, which is mocked as an instance of `HexaPDF::Layout::Page`, is unexpectedly receiving the `box` message within your `create_toc` method. This suggests that the `create_toc` method is attempting to access the `box` method on a `Page` object.

To resolve this, you need to properly mock the `box` method for the `toc_page`. The `box` method likely returns a `HexaPDF::Layout::Box` object or a similar construct that provides access to the page dimensions (width, height, etc.).

Here's the adjustment to your spec to mock the `box` method on `toc_page`:

### Adjusted Spec:

```ruby
describe '#create_toc' do
  # ... [other setup code] ...

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:page_box) { instance_double("HexaPDF::Layout::Box") }
  let(:toc_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas) }
  let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)
    allow(toc_page).to receive(:box).and_return(page_box)
    allow(page_box).to receive_messages(width: 612, height: 792)

    # Stubbing necessary canvas methods used in create_toc
    # ... [stubs for page_canvas methods] ...

    builder.instance_variable_set(:@policy_book_document, document)
  end

  it 'creates the table of contents correctly' do
    expect { create_toc }.not_to raise_error
    # ... [additional expectations] ...
  end
end
```

### Key Changes:

1. **Added Mock for Box on Page:** Now `toc_page` properly responds to the `box` method, returning a mocked `page_box`.
2. **Mocked Width and Height on Box:** The `page_box` is mocked to provide `width` and `height`, which are typical properties or methods you'd access to get the dimensions of a page.

### Additional Notes:

- Ensure that the width and height values (`612` and `792`) match the expected dimensions for your tests.
- If there are other properties or methods accessed on `page_box` within `create_toc`, you should also mock those accordingly.

Still the same error about the `value` method not implemented by HexaPDF::Layout::Box

  describe '#create_toc' do
    subject(:create_toc) { builder.send(:create_toc, documents, page_number, insert_at_index) }

    let(:policy) { FactoryBot.create(:published_document, company: policy_book.company) }
    let(:procedure) { FactoryBot.create(:published_procedure, company: policy_book.company) }
    let(:form) { FactoryBot.create(:published_form, company: policy_book.company) }

    let(:documents) do
      {
        'Policy Category' => [policy],
        'Procedure Category' => [procedure],
        'Form Category' => [form]
      }
    end

    let(:page_number) { 1 }
    let(:insert_at_index) { 2 }
    let(:toc_page) { instance_double("HexaPDF::Layout::Page") }
    let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
    let(:page_x) { 612 }
    let(:page_y) { 792 }
    let(:page_box) { instance_double("HexaPDF::Layout::Box") }
    let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

    before do
      allow(HexaPDF::Document).to receive(:new).and_return(document)
      #allow(page_canvas).to receive(:box).and_return(page_box)
      allow(page_canvas).to receive(:font)
      allow(document).to receive(:config)
      allow(page_canvas).to receive(:text)
      allow(page_canvas).to receive(:fill_color)
      allow(page_canvas).to receive(:stroke_color)
      allow(page_canvas).to receive(:line_width)
      allow(page_canvas).to receive(:line)
      allow(page_canvas).to receive(:stroke)
      allow(page_box).to receive(:width).and_return(page_x)
      allow(page_box).to receive(:height).and_return(page_y)
      allow(toc_page).to receive(:box).and_return(page_box)
      builder.instance_variable_set(:@policy_book_document, document)
      # ... any other canvas methods used in your create_toc method
    end

    it 'creates the table of contents correctly' do
      expect { create_toc }.not_to raise_error

      # Additional expectations about the state of the page_canvas or the document
      # after create_toc has been executed. For example:
      # expect(page_canvas).to have_received(:text).with(...)
    end
  end

       expected no Exception, got #<RSpec::Mocks::MockExpectationError: #<InstanceDouble(HexaPDF::Layout::Box) (anonymous)> received unexpected message :value with (no args)> with backtrace:

The error message indicates that we are incorrectly mocking the `value` method on an instance of `HexaPDF::Layout::Box`, which is not a method of that class. This suggests that the `create_toc` method of your `PolicyBookBuilder` service is calling the `value` method on a `Box` object, but this method doesn't exist in HexaPDF's API.

Given this information, we need to adjust our approach. Instead of trying to mock a non-existent `value` method, we should mock the methods that are actually used to obtain the dimensions of a page in HexaPDF. Typically, these would be the `width` and `height` methods, which you've already mocked. 

However, if your `create_toc` method is directly accessing a `value` method on a `Box` object, you might need to refactor your service code to use the correct methods (`width` and `height`) for obtaining the dimensions. Alternatively, if `value` is a custom method in your application, you should ensure it's properly mocked.

Hereâ€™s an adjustment to the spec that assumes you will refactor the `create_toc` method to use `width` and `height`:

### Adjusted Spec:

```ruby
describe '#create_toc' do
  # ... [other setup code] ...

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:page_box) { instance_double("HexaPDF::Layout::Box") }
  let(:toc_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas, box: page_box) }
  let(:document) { instance_double("HexaPDF::Document", pages: Array.new(4, toc_page)) }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)
    allow(page_box).to receive_messages(width: 612, height: 792)

    # Stubbing necessary canvas methods used in create_toc
    # ... [stubs for page_canvas methods] ...

    builder.instance_variable_set(:@policy_book_document, document)
  end

  it 'creates the table of contents correctly' do
    expect { create_toc }.not_to raise_error
    # ... [additional expectations] ...
  end
end
```

### Key Changes:

1. **Refactored Approach:** Assumes that `create_toc` in the service code will be refactored to use `width` and `height` instead of a non-existent `value` method.
2. **Mocked Width and Height on Box:** The `page_box` is still mocked to provide `width` and `height`.

### Additional Notes:

- Ensure your `create_toc` method in the service is updated to use `width` and `height` of the `Box` object for dimensions.
- If `create_toc` still requires a `value` method, then either this method should be correctly implemented in your application, or the service code should be adjusted to not rely on such a method.

  def create_title_page
    title_page = policy_book_document.pages.insert(0)
    page_x, page_y = title_page.box.value[2..3]

    page_canvas = title_page.canvas
Above is how the method is looking like

Thank you for providing the `create_title_page` method from your `PolicyBookBuilder` service. This method indeed attempts to access the dimensions of the title page using `title_page.box.value[2..3]`. However, this approach might not align with the HexaPDF's API for accessing the dimensions of a `Box` object, hence the issues you are encountering in your tests.

In HexaPDF, the `Box` object represents a rectangular area and usually provides methods like `width` and `height` to access its dimensions. Instead of using `value[2..3]`, you should directly use these methods to get the dimensions.

Here's how you can adjust the `create_title_page` method:

### Adjusted `create_title_page` Method:

```ruby
def create_title_page
  title_page = policy_book_document.pages.insert(0)
  
  # Use width and height methods instead of value[2..3]
  page_x = title_page.box.width
  page_y = title_page.box.height

  page_canvas = title_page.canvas

  # ... rest of your method implementation ...
end
```

### Adjusting the Test Spec:

With this change in your service code, you should adjust your test spec to mock the `width` and `height` methods on the `Box` object:

```ruby
describe '#create_title_page' do
  # ... [other setup code] ...

  let(:page_canvas) { instance_double("HexaPDF::Content::Canvas") }
  let(:page_box) { instance_double("HexaPDF::Layout::Box") }
  let(:title_page) { instance_double("HexaPDF::Layout::Page", canvas: page_canvas, box: page_box) }
  let(:document) { instance_double("HexaPDF::Document", pages: [title_page]) }

  before do
    allow(HexaPDF::Document).to receive(:new).and_return(document)
    allow(page_box).to receive_messages(width: 612, height: 792)

    # Stubbing necessary canvas methods used in create_title_page
    # ... [stubs for page_canvas methods] ...

    builder.instance_variable_set(:@policy_book_document, document)
  end

  it 'creates the title page correctly' do
    # ... your test implementation ...
  end
end
```

With these adjustments, both your service code and your test spec should align better with HexaPDF's API, and you should no longer encounter the `value` method error.

Tell me the overall process that is happening in the HexaPDF under my policy_book_builder service. Use variables whenever the service is using them. I want to isolate all the steps happening around it

Certainly! Let's break down the overall process happening in your `PolicyBookBuilder` service that interacts with HexaPDF. I'll explain the sequence of actions, referencing the relevant variables and methods as they appear in your service code.

### 1. Initialization
When an instance of `PolicyBookBuilder` is created, it initializes with a `company`, `user`, and `creation_date`. The builder sets the current tenant (for multitenancy purposes), defines the first profile name for the user, and initializes a new `PolicyBook` object or uses an existing one linked to the company.

```ruby
def initialize(company:, user:, creation_date:)
  @company = company
  @user = user
  @creation_date = creation_date.in_time_zone(@company.time_zone)
  # ... other initialization steps ...
end
```

### 2. PDF Document Creation
A new HexaPDF document is created (`@policy_book_document`) with a default media box size set to 'Letter'. Fonts are added to this document, and a configuration for handling unknown glyphs is set.

```ruby
def policy_book_document
  @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
    # Configuration for the PDF document
  end
end
```

### 3. Generating Pages
Various methods are called to generate different parts of the policy book:

- **Title Page**: Generated using either a custom title page or a default one created in `create_title_page`. This involves setting up text and images on the page.
  
```ruby
def create_title_page
  title_page = policy_book_document.pages.insert(0)
  # Layout for title page
end
```

- **Pre-TOC and Preface**: If applicable, pre-Table of Contents and preface pages are added.

- **Merging Documents**: Published documents are merged into the policy book PDF. This involves importing pages from other PDF documents.

```ruby
def merge_documents
  # Merging each document into the policy book
end
```

- **Table of Contents (TOC)**: A TOC is created, listing all the documents included. Page numbers are assigned accordingly.

```ruby
def create_toc(documents, page_number, insert_at)
  # Creating Table of Contents
end
```

### 4. Stamping Headers and Footers
Each page of the policy book is stamped with headers and footers. This includes company logo, policy book title, and other relevant information.

```ruby
def stamp_pages(page_number = 1)
  # Stamping each page with headers and footers
end
```

### 5. Saving the Policy Book
Finally, the completed policy book is saved to a specified directory.

```ruby
def save_policy_book!
  # Saving the policy book to a file
end
```

### 6. Cleanup
There is also a method to destroy (delete) the generated policy book file if needed.

```ruby
def destroy
  # Deleting the policy book file
end
```

### Additional Context
Throughout this process, various helper methods and configurations are used, such as setting colors, managing text layout, and handling images. These are all essential to ensure that each page of the policy book is laid out correctly according to the specified requirements.

The overall process orchestrates the creation of a policy book from start to finish, merging content from various sources, adding standard elements like headers and footers, and ensuring everything is formatted consistently before saving the final PDF document.

# frozen_string_literal: false

# Take the users profile and generate a full policy book from it. Will also grab documents assigned
# in the distribute documents section of the application
class PolicyBookBuilder
  include ActionView::Helpers::TextHelper
  include HexaPDF::Layout
  OUTPUT = Rails.env.development? || (Rails.env.starts_with? 'qa')
  FILEDIR = Rails.root.join('tmp', 'policy_book').to_s.freeze
  DEFAULT_FONT = 'Helvetica'.freeze
  DEFAULT_LINE_WIDTH = 0.8
  STATIC_IMAGES = {
    footer: 'policy_book/policy-book-footer.png',
    icon: 'policy_book/policy-icon.png',
    logo: 'policy_book/policy-logo.png',
    title_page: 'policy_book/policy-book-title-page.png'
  }.freeze
  TOC_Y_OFFSET_STEPS = {
    start: 12.95,
    pre_category_step: 0.25,
    post_category_step: 0.1,
    pre_document_title_step: 0.35,
    post_documents_titles_step: 0.3
  }.freeze
  TOC_PAGE_NUMBER_LINE_STRING = '. '.freeze
  TOC_MAX_LINE_LENGTH = 80
  TOC_TITLE_MAX_LINE_LENGTH = 50
  TOC_FONT_COLOUR = '#1c77b7'.freeze
  SMALL_CHARACTERS = "Itifjl1.!\'\"[]{}|:;,r ".freeze
  TOC_LINK_FONT_COLOUR = '#FFFFFF'.freeze
  TOC_PAGE_NUMBER = 2
  WIDTH = 188
  HEIGHT = 786
  FONT_FILE_NAME = 'Helvetica/Helvetica.ttf'.freeze

  def initialize(company:, user:, creation_date:)
    @company = company
    ActsAsTenant.current_tenant = @company
    @user = user
    @profile_name = @user.first_profile_name
    @policy_book = @company.policy_book || PolicyBook.new(company: @company)
    @creation_date = creation_date.in_time_zone(@company.time_zone)
    primary_document_type
  rescue StandardError => e
    log_output "#{e.message}\n\n#{e.backtrace.join("\n")}"
    raise
  end

  def filename
    "#{@policy_book.current_title.parameterize}-#{file_creation_date}.pdf"
  end

  def create
    log_output 'Creating Title Page...'
    generate_title_page

    log_output 'Creating Pre Table of Contents Page...'
    create_pre_toc

    log_output 'Creating Preface...'
    merge_preface unless @policy_book.exclude_preface?

    log_output 'Merging Documents...'
    merge_documents

    log_output 'Creating Table of Contents...'
    # 0 based index position
    # the preface can 1 - n pages
    insert_at_index = title_page_override ? (1 + page_counts[:title_page][:number_of_pages]) : 2
    insert_at_index += page_counts[:preface][:number_of_pages] unless @policy_book.exclude_preface?

    page_counts[:pre_toc] = { number_of_pages: 0 }
    add_title_toc_numbers(documents, insert_at_index)

    toc_page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    create_toc(documents, toc_page_number_starts_at, insert_at_index)

    # figure out how long the toc was and then write the document page numbers
    page_number_starts_at = (insert_at_index + 1) + page_counts[:toc][:number_of_pages]
    add_toc_page_numbers(documents, insert_at_index, page_number_starts_at)

    log_output 'Creating Final Page...'
    policy_book_document.pages.insert(-1)

    log_output 'Adding Header/Footers...'
    stamp_pages

    log_output 'Writing Completed Policy Book...'
    save_policy_book!

    log_output 'Complete.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'create') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed to create policy book',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id
          }
        )
      )
    end
    false
  end

  def destroy
    log_output 'Getting destination file...'
    dest = File.join(create_tmp_directories, filename)
    log_output 'Deleting file if it exists...'
    File.delete(dest) if File.file? dest
    log_output 'File deleted.'
    true
  rescue StandardError => e
    log_output e.message
    Rails.logger.tagged(self.class, 'destroy') do
      Rails.logger.error(
        LogEntry.new(
          description: 'Failed delete the policy book file',
          category: self.class,
          exception: e,
          extra_details: {
            error_messages: e.message,
            company_id: @company.id,
            user_id: @user.id,
            destination_path: dest || 'no_destination_path'
          }
        )
      )
    end
    false
  end

  def policy_book_pdf_path
    @policy_book_pdf_path || ''
  end

  # Gets all of the documents into a list
  def documents
    @documents ||= @user.published_documents
                        .includes(document_category_options: :category_option)
                        .by_document_types(@policy_book.included_document_types)
                        .group_by(&:preferred_category_option)
                        .freeze
  end

  # Used for building dynamic text that depends on constituent document types
  def primary_document_type
    @primary_document_type ||= if @policy_book.include_policies?
                                 :policy
                               elsif @policy_book.include_procedures?
                                 :procedure
                               elsif @policy_book.include_forms?
                                 :form
                               else
                                 :empty
                               end
  end

  private

  def host
    @host ||= Rails.application.secrets.policy_book_asset_root_url.gsub('#', @company.subdomain)
  end

  def policy_book_document
    @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
      doc.config['page.default_media_box'] = :Letter
      font = doc.fonts.add(font_file)
      unknown_glyph = font.decode_utf8('?').first
      doc.config['font.on_missing_glyph'] = proc { unknown_glyph }
    end
  end

  def page_counts
    @page_counts ||= { toc: { number_of_pages: 0 } }
  end

  def title_page_override
    @title_page_override ||= @policy_book.title_page_override
  end

  def header_primary_colour
    @policy_book.header_primary_colour
  end

  def header_secondary_colour
    @policy_book.header_secondary_colour
  end

  def header_tertiary_colour
    @policy_book.header_tertiary_colour
  end

  def policy_book_logo_icon
    @policy_book_logo_icon ||= uri(STATIC_IMAGES[:icon]).open { |file| write_tempfile(file) }
  end

  def mypolicies_logo
    @mypolicies_logo ||= uri(STATIC_IMAGES[:logo]).open { |file| write_tempfile(file) }
  end

  def title_page_image
    @title_page_image ||= uri(STATIC_IMAGES[:title_page]).open { |file| write_tempfile(file) }
  end

  def policy_book_footer
    @policy_book_footer ||= uri(STATIC_IMAGES[:footer]).open { |file| write_tempfile(file) }
  end

  def uri(url)
    return Rails.root.join("app/assets/images/#{url}") if Rails.env.development? || Rails.env.test?

    URI.parse(ActionController::Base.helpers.asset_path(url, host: host))
  end

  def write_tempfile(file)
    Tempfile.new(['', '.png'], encoding: file.read.encoding).tap do |tmp|
      tmp.binmode
      file.rewind
      tmp.write(file.read)
    end
  end

  def company_logo
    return @company_logo if @company_logo

    @company_logo = @policy_book.logo
    begin
      @company_logo.policy_book.cache! if @policy_book.logo
    rescue StandardError
      raise 'Failed to retrieve logo.'
    end
  end

  def file_creation_date
    @creation_date.strftime('%Y-%m-%d-%H-%M-%S')
  end

  def policy_book_creation_date
    I18n.t('policy_book.pdf.body.created', date: @creation_date.to_date.to_formatted_s(:long))
  end

  # take the source file and merge it into the hexapdf document
  # also track the number of pages in the document
  def merge_document_pdf(title, source_path)
    pdf = HexaPDF::Document.open(source_path)
    page_counts[title] = { number_of_pages: pdf.pages.count }
    log_output("Document page count of: #{page_counts[title][:number_of_pages]}")
    pdf.pages.each { |page| policy_book_document.pages.add(policy_book_document.import(page)) }
  end

  # take a list of documents and merge them into the taret hexapdf object
  def merge_documents
    documents.sort_by { |category, _documents| category }.each do |arr|
      arr[1].sort_by(&:title).each do |document|
        file = document.content_pdf_file
        begin
          file.cache!
        rescue StandardError => e
          Rails.logger.tagged(self.class, 'merge_documents') do
            Rails.logger.error(
              LogEntry.new(
                description: 'Failed to find a content PDF file for document.',
                category: self.class,
                exception: e,
                extra_details: {
                  error_messages: e.message,
                  company_id: @company.id,
                  user_id: @user.id,
                  document_id: document.id
                }
              )
            )
          end
          next
        end
        log_output("Merging Document: #{document.title}")
        merge_document_pdf(document.title, file.path)
      end
    end
  rescue StandardError => e
    raise "Failed to merge documents into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def merge_preface
    file = @policy_book.preface_pdf_file
    file.cache!
    merge_document_pdf(:preface, file.path)
  rescue StandardError => e
    raise "Failed to merge preface into policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the header onto a page canvas that has been passed in
  def add_header(page_canvas, page_x, page_y)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    policy_book_rectangle_end_x = sixteenth_x * 3.25
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 7.5
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 4
    # rough approximation for centering; should be 'close enough'
    header_middle_text = I18n.t("policy_book.pdf.header.middle.#{primary_document_type}")
    policy_book_title_padding = (11 - header_middle_text.length) * 0.05
    policy_book_title_position_x = sixteenth_x * (8 + policy_book_title_padding)
    rectangle_height = 45
    header_height = page_y - rectangle_height
    policy_book_font_size = 16
    info_font_size = 10
    policy_book_title_vertical_offset = 16
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(mypolicies_logo, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # header bar middle rectangle: the famous "orange box"
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, policy_book_rectangle_end_x, rectangle_height)
    page_canvas.fill

    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: policy_book_font_size)
    page_canvas.text(
      header_middle_text,
      at: [policy_book_title_position_x, header_height + policy_book_title_vertical_offset]
    )
    page_canvas.fill_color

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def ellipses(text, max_length = 75)
    (text || '').length > max_length ? text[0..(max_length - 3)].gsub(/\s\w+\s*$/, '...') : text
  end

  def options_for_document_title(title)
    title = ellipses(title)
    case title.length
    when 0..10
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.15,
        small_character_offset: 0,
        character_limit: 25 }
    when 11..25
      { sections: [title],
        font_size: 15,
        no_small_character_offset: 0.15,
        character_offset: 0.13,
        small_character_offset: 0.02,
        character_limit: 25 }
    when 26..75
      split_title = word_wrap(title, line_width: 25).split("\n")
      { sections: split_title,
        font_size: split_title.length > 2 ? 13 : 15,
        no_small_character_offset: 0.1,
        character_offset: 0.1,
        small_character_offset: 0.08,
        character_limit: 25 }
    end
  end

  # stamp the header onto a document page
  def add_document_header(page_canvas, page_x, page_y, title)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    policy_book_logo_position_x = sixteenth_x / 2
    info_rectangle_start_x = sixteenth_x * 10.75
    logo_rectangle_end_x = sixteenth_x * 4.75
    info_start_x = sixteenth_x * 11
    company_logo_position_x = sixteenth_x * 1.5
    rectangle_height = 45
    header_height = page_y - rectangle_height
    info_font_size = 10
    logo_vertical_offset = 12
    logo_y_position = header_height + logo_vertical_offset
    logo_height = 25
    info_text_vertical_offsets = [30, 18, 7] # top, middle, bottom

    title_options = options_for_document_title(title)

    # logo rectangle
    set_canvas_colour(page_canvas, header_primary_colour)
    page_canvas.rectangle(0, header_height, logo_rectangle_end_x, rectangle_height)
    page_canvas.fill

    page_canvas.image(policy_book_logo_icon, at: [policy_book_logo_position_x, logo_y_position], height: logo_height)
    if company_logo
      page_canvas.image(
        company_logo.policy_book.path,
        at: [company_logo_position_x, logo_y_position],
        height: logo_height
      )
    end

    # policy book rectangle
    set_canvas_colour(page_canvas, header_secondary_colour)
    page_canvas.rectangle(logo_rectangle_end_x, header_height, info_rectangle_start_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_secondary_colour)
    page_canvas.font(DEFAULT_FONT, size: title_options.fetch(:font_size))

    # y_padding is the pixel height of the space between the text
    num_sections = title_options[:sections].length
    y_padding = (rectangle_height - (info_font_size * num_sections)) / (num_sections + 1)

    title_options[:sections].reverse.each_with_index do |section, index|
      small_char_count = section.count SMALL_CHARACTERS
      unless small_char_count.zero?
        large_char_offset = (section.length - small_char_count) * title_options.fetch(:character_offset)
      end
      large_char_offset ||= section.length * title_options.fetch(:no_small_character_offset)
      small_char_offset = small_char_count.zero? ? 0 : small_char_count * title_options.fetch(:small_character_offset)

      font_offset = title_options[:sections].length > 2 ? 8.00 : 7.75
      document_title_x = sixteenth_x * (font_offset - (large_char_offset + small_char_offset))
      document_title_y = y_padding + ((info_font_size + 1 + y_padding) * index)
      page_canvas.font(font_file, variant: :bold)
      page_canvas.text(section, at: [document_title_x, header_height + document_title_y])
      page_canvas.fill_color
    end

    # info rectangle
    set_canvas_colour(page_canvas, header_tertiary_colour)
    page_canvas.rectangle(info_rectangle_start_x, header_height, page_x, rectangle_height)
    page_canvas.fill
    set_font_colour(page_canvas, header_tertiary_colour)
    page_canvas.font(DEFAULT_FONT, size: info_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [info_start_x, header_height + info_text_vertical_offsets.first])
    page_canvas.font(DEFAULT_FONT, size: info_font_size)
    page_canvas.text(@profile_name, at: [info_start_x, header_height + info_text_vertical_offsets.second])
    page_canvas.text(policy_book_creation_date, at: [info_start_x, header_height + info_text_vertical_offsets.last])
    page_canvas.fill_color
  rescue StandardError => e
    raise "Failed to add header to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # stamp the footer image on the page
  def add_footer(page_canvas, page_x, page_number)
    # Turning the page into 16 column design
    sixteenth_x = page_x / 16
    page_number_start_x = sixteenth_x * 15.5
    character_offset = 0.1875
    line_height = 7
    font_size = 10
    subdomain = @company.subdomain
    url = "#{subdomain}.myPolicies.com"
    url_offset_x = sixteenth_x * (8 - subdomain.length * character_offset)

    page_canvas.image(policy_book_footer, at: [0, 0], width: page_x)
    white(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)
    page_canvas.text(page_number.to_s, at: [page_number_start_x, line_height])
    fragment = build_fragment(I18n.t('policy_book.pdf.footer.table_of_contents'), font_size, TOC_PAGE_NUMBER,
                              hex_to_rgb(TOC_LINK_FONT_COLOUR), :bold)
    layouter.fit([fragment], 100, 100).draw(page_canvas, sixteenth_x, 14)
    page_canvas.text(url, at: [url_offset_x, line_height])
  rescue StandardError => e
    raise "Failed to add footer to policy book page: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def generate_title_page
    if title_page_override.present?
      title_page_override.cache!
      merge_document_pdf(:title_page, title_page_override.path)
    else
      create_title_page
    end
  end

  def build_fragment(text, font_size, destination, text_colour, variant = nil)
    toc_base_font = policy_book_document.fonts.add(font_file, variant: variant)
    HexaPDF::Layout::TextFragment.create(text,
                                         { font: toc_base_font,
                                           font_size: font_size,
                                           overlays: [[:link, { dest: [destination, :XYZ, WIDTH, HEIGHT, 0] }]],
                                           fill_color: text_colour })
  end

  # create the title page for the document
  def create_title_page
    title_page = policy_book_document.pages.insert(0)
    page_x, page_y = title_page.box.value[2..3]

    page_canvas = title_page.canvas

    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    company_name_y_position = sixteenth_y * 14
    policy_book_y_position = sixteenth_y * 13.25
    profile_y_position = sixteenth_y * 12.5
    date_created_y_position = sixteenth_y * 11.5
    title_image_y_position = sixteenth_y * 2
    underline_y_position = sixteenth_y * 12.15
    underline_x_position = [sixteenth_x, sixteenth_x * 15]
    large_font_size = 30
    medium_font_size = 20

    black(page_canvas)

    page_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    page_canvas.text(@company.name, at: [sixteenth_x, company_name_y_position])

    page_canvas.font(DEFAULT_FONT, size: large_font_size)
    page_canvas.text(
      I18n.t("policy_book.pdf.title_page.subtitle.#{primary_document_type}"),
      at: [sixteenth_x, policy_book_y_position]
    )

    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(@profile_name, at: [sixteenth_x, profile_y_position])

    grey_lightish_stroke(page_canvas)
    page_canvas.line_width = DEFAULT_LINE_WIDTH
    page_canvas.line(underline_x_position[0], underline_y_position, underline_x_position[1], underline_y_position)
    page_canvas.stroke

    grey_lightish(page_canvas)
    page_canvas.font(DEFAULT_FONT, size: medium_font_size)
    page_canvas.text(policy_book_creation_date, at: [sixteenth_x, date_created_y_position])

    page_canvas.image(title_page_image, at: [0, title_image_y_position], width: page_x)
    page_counts[:title_page] = { number_of_pages: 1 }
  rescue StandardError => e
    raise "Failed to create title page for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # add a page that displayes a single title in the center of the page
  # wrapped to a certain amount on each line
  def create_pre_toc(insert_at_index = 2)
    pre_toc_page = policy_book_document.pages.insert(insert_at_index)
    page_x, page_y = pre_toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    sixteenth_y = page_y / 16
    font_size = 30
    character_offset = 0.20
    character_line_limit = 28

    pre_toc_canvas = pre_toc_page.canvas
    black(pre_toc_canvas)
    pre_toc_canvas.font(DEFAULT_FONT, size: font_size, variant: :bold)

    # split the text and center it
    wrapped_title = word_wrap(@policy_book.current_title, line_width: character_line_limit)
    title_sections = wrapped_title.split("\n")
    title_sections.each_with_index do |section, index|
      x_offset = sixteenth_x * (8 - section.length * character_offset)
      pre_toc_canvas.text(section, at: [x_offset, sixteenth_y * (8 - index)])
    end
  rescue StandardError => e
    raise "Failed to create pre table of contents for policy book: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # create the table of contents
  # split into multiple pages recursively
  def create_toc(documents, page_number, insert_at = 2)
    toc_page = policy_book_document.pages[insert_at]
    page_counts[:toc][:number_of_pages] += 1
    binding.pry
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    document_title_start_x = sixteenth_x * 2
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    underline_y_position = sixteenth_y * 13.6
    underline_x_end_position = sixteenth_x * 15
    toc_title_position = [sixteenth_x * 4.9, sixteenth_y * 14]
    large_font_size = 29
    medium_font_size = 22
    small_font_size = 12

    toc_canvas = toc_page.canvas
    black(toc_canvas)

    toc_canvas.font(DEFAULT_FONT, size: large_font_size, variant: :bold)
    toc_canvas.text(I18n.t('policy_book.pdf.body.table_of_contents'), at: toc_title_position)

    grey_lightish_stroke(toc_canvas)
    toc_canvas.line_width = DEFAULT_LINE_WIDTH
    toc_canvas.line(sixteenth_x, underline_y_position, underline_x_end_position, underline_y_position)
    toc_canvas.stroke

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      toc_canvas.font(DEFAULT_FONT, size: medium_font_size)
      grey_lightish(toc_canvas)

      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      toc_canvas.text(ellipses(category, TOC_TITLE_MAX_LINE_LENGTH), at: [sixteenth_x, (sixteenth_y * y_offset) - 10])
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key? document.title

        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        dest_page_number = page_number + page_counts.dig(:pre_toc, :number_of_pages) - 1
        fragment = build_fragment(ellipses(document.title, TOC_MAX_LINE_LENGTH), small_font_size, dest_page_number,
                                  hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 600, 400).draw(toc_canvas, document_title_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      create_toc(document_index, page_number, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to create ToC for (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Add page numbers onto the table of contents.
  # Since we don't know how many pages there will be upfront, we have to
  # number the document pages after offsetting the number of table of contents pages.
  def add_toc_page_numbers(documents, start_at, page_number)
    toc_page = policy_book_document.pages[start_at]
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_x = page_x / 16
    padding_offset_start_x = sixteenth_x * 2
    padding_offset_stop_x = sixteenth_x * 13.5
    page_number_start_x = sixteenth_x * 14
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    small_font_size = 12
    document_title_character_offset = 0.2
    toc_dot_interval = 3.0
    padding_default = 65 # random number of text characters before running off the page

    toc_canvas = toc_page.canvas

    y_offset = TOC_Y_OFFSET_STEPS[:start]

    # use this to track everything that has not been placed on the page yet.
    # this will let us create another toc page if needed and know which documents need to still be written
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step] + TOC_Y_OFFSET_STEPS[:post_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      arr[1].sort_by(&:title).each do |document|
        title = document.title
        next unless page_counts.key?(title)
        toc_canvas.font(DEFAULT_FONT, size: small_font_size)
        set_canvas_colour(toc_canvas, TOC_FONT_COLOUR)

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        title_length = ellipses(title, TOC_MAX_LINE_LENGTH).length
        padding = padding_default - title_length
        (0..padding).each do |i|
          padding_offset = padding_offset_start_x + (sixteenth_x * (title_length * document_title_character_offset) + (sixteenth_x * (i / toc_dot_interval)))
          break if padding_offset > padding_offset_stop_x

          toc_canvas.text(TOC_PAGE_NUMBER_LINE_STRING, at: [padding_offset, (sixteenth_y * y_offset) - 8])
        end

        fragment = build_fragment(page_number.to_s, small_font_size, page_number - 1, hex_to_rgb(TOC_FONT_COLOUR))
        layouter.fit([fragment], 100, 100).draw(toc_canvas, page_number_start_x, (sixteenth_y * y_offset))

        page_counts[title][:document_start_page] = page_number
        page_number += page_counts[title][:number_of_pages]
        page_counts[title][:next_documents_page] = page_number

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    # recursively call until all documents page numbers have been written
    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_toc_page_numbers(document_index, start_at + 1, page_number)
    end
  rescue StandardError => e
    raise "Failed to add ToC page numbers for (#{start_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def add_title_toc_numbers(documents, insert_at = 2)
    toc_page = policy_book_document.pages.insert(insert_at)
    page_counts[:pre_toc][:number_of_pages] += 1
    page_x, page_y = toc_page.box.value[2..3]
    sixteenth_y = page_y / 16
    max_toc_content = sixteenth_y * 2
    y_offset = TOC_Y_OFFSET_STEPS[:start]
    document_index = documents.deep_dup

    documents.sort_by { |category, _documents| category }.each do |arr|
      y_offset -= TOC_Y_OFFSET_STEPS[:pre_category_step]
      break if (sixteenth_y * y_offset) < max_toc_content

      category = arr[0]
      y_offset -= TOC_Y_OFFSET_STEPS[:post_category_step]

      arr[1].sort_by(&:title).each do |document|
        next unless page_counts.key? document.title

        y_offset -= TOC_Y_OFFSET_STEPS[:pre_document_title_step]
        break if (sixteenth_y * y_offset) < max_toc_content

        document_index[category].delete_if { |doc| doc.title == document.title }
      end
      break if (sixteenth_y * y_offset) < max_toc_content

      document_index.delete(category)
      y_offset -= TOC_Y_OFFSET_STEPS[:post_documents_titles_step]
    end

    if (sixteenth_y * y_offset) < max_toc_content && document_index.keys.any?
      add_title_toc_numbers(document_index, insert_at + 1)
    end
  rescue StandardError => e
    raise "Failed to add title toc numbers (#{insert_at - 1}): #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  # Stamp the header and footer onto each page of the policy book
  def stamp_pages(page_number = 1)
    # remove pages that are not documents
    document_page_counts = page_counts.select { |_key, values| values.key?(:next_documents_page) }

    # title_page = 1...n
    # toc = n +1
    title_page_index = title_page_override.present? ? [*1..page_counts[:title_page][:number_of_pages]] : []
    regular_header_index = [*1..page_counts[:title_page][:number_of_pages] + 1]
    # Don't add headers to custom title pages
    regular_header_index -= title_page_index
    # offset for the preface
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:preface][:number_of_pages])).to_a if page_counts[:preface]
    # offset for the toc
    regular_header_index += ((regular_header_index.last + 1)..(regular_header_index.last + page_counts[:toc][:number_of_pages])).to_a
    # last page (blank one)
    regular_header_index << policy_book_document.pages.count
    # compare policy_book_document.pages vs regular_header_index
    policy_book_document.pages.each do |page|
      if title_page_index.include?(page_number)
        page_number += 1
        next
      end
      page_x, page_y = page.box.value[2..3]
      page_canvas = page.canvas(type: :overlay)
      if regular_header_index.include?(page_number)
        add_header(page_canvas, page_x, page_y)
      else
        page_number_hash = document_page_counts.select do |_key, hash|
          hash[:next_documents_page] > page_number && hash[:document_start_page] <= page_number
        end
        page_title = Hash[page_number_hash].keys.first || ''

        add_document_header(page_canvas, page_x, page_y, page_title)
      end
      add_footer(page_canvas, page_x, page_number)
      page_number += 1
    end
  rescue StandardError => e
    raise "Failed to stamp header/footer for page #{page_number}: #{e.message}\n\n#{e.backtrace.join("\n")}"
  end

  def save_policy_book!
    binding.pry
    dest = File.join(create_tmp_directories, filename)
    policy_book_document.write(dest, optimize: true)
    raise "Failed to find policy book file after save: #{dest}" unless File.file? dest

    @policy_book_pdf_path = dest
  end

  # make sure that all of the folders in the tmp directory exist or create them
  def create_tmp_directories
    Dir.mkdir FILEDIR unless File.directory?(FILEDIR)

    company_dir = File.join(FILEDIR, 'company')
    Dir.mkdir company_dir unless File.directory?(company_dir)

    company_id_dir = File.join(company_dir, @company.id.to_s)
    Dir.mkdir company_id_dir unless File.directory?(company_id_dir)

    company_user_dir = File.join(company_id_dir, 'user')
    Dir.mkdir company_user_dir unless File.directory?(company_user_dir)

    company_user_id_dir = File.join(company_user_dir, @user.id.to_s)
    Dir.mkdir company_user_id_dir unless File.directory?(company_user_id_dir)

    company_user_id_dir
  end

  # Set the colour based on the RGB values passed in
  def colour(page_canvas, red, green, blue)
    page_canvas.fill_color(red, green, blue)
  end

  # set the stroke colour based on RGB values passed in
  def stroke_colour(page_canvas, red, green, blue)
    page_canvas.stroke_color(red, green, blue)
  end

  def set_canvas_colour(page_canvas, hex_colour)
    colour(page_canvas, *hex_to_rgb(hex_colour))
  end

  # Determine the luminosity of the hex colour passed in and use it to determine if
  # black or white should be used as a font colour
  def set_font_colour(page_canvas, hex_colour)
    r, g, b = hex_to_rgb(hex_colour)
    (0.2126 * r + 0.7152 * g + 0.0722 * b) <= 180 ? white(page_canvas) : black(page_canvas)
  end

  # --v
  def white(page_canvas)
    colour(page_canvas, 255, 255, 255)
  end

  # --v
  def black(page_canvas)
    colour(page_canvas, 0, 0, 0)
  end

  # --v
  def grey_lightish(page_canvas)
    colour(page_canvas, 193, 193, 193)
  end

  # --v
  def grey_lightish_stroke(page_canvas)
    stroke_colour(page_canvas, 193, 193, 193)
  end

  def hex_to_rgb(hex)
    r = hex[1..2].to_i(16)
    g = hex[3..4].to_i(16)
    b = hex[5..6].to_i(16)
    [r, g, b]
  end

  # log output to the console depending on the ENV that you are in
  def log_output(message)
    return unless OUTPUT
    return puts "PolicyBookBuilder::: #{message}" if Rails.env.development?

    Rails.logger.tagged('PolicyBookBuilder') { Rails.logger.info(message) }
  end

  def layouter
    TextLayouter.new
  end

  def font_file
    return @font_file if @font_file

    manifest_file = Rails.application.assets_manifest.assets[FONT_FILE_NAME]
    @font_file =
      if manifest_file
        File.join(Rails.application.assets_manifest.directory, manifest_file)
      else
        Rails.application.assets&.[](FONT_FILE_NAME)&.filename
      end
  end
end

That is my service. Assuming it starts in line 1, I want you to tell me the whole pdf generation process (like all chained interactions with the HexaPDF object) and provide the line number to the service line. My purpose is to understand what parts of the HexaPDF are being used during the pdf generation process.

To detail the PDF generation process within your `PolicyBookBuilder` service and the interactions with HexaPDF, let's walk through the steps, highlighting where each HexaPDF-related action occurs in your service. I'll provide line numbers to help you trace each action within the service.

### 1. Initialization of HexaPDF Document
- **Line 105**: The `policy_book_document` method initializes a new HexaPDF::Document object. This document is configured with a default page size and font handling for unknown glyphs.

### 2. Generating the Title Page
- **Lines 245-291 (`create_title_page`)**: This method creates the title page for the PDF, using methods like `page.canvas` to draw text and images. The canvas is used for drawing operations.

### 3. Pre-Table of Contents (TOC) Page Creation
- **Lines 293-316 (`create_pre_toc`)**: Generates a pre-TOC page, inserting it into the PDF and using canvas operations to add text.

### 4. Preface Merging
- **Lines 318-324 (`merge_preface`)**: If applicable, merges a preface PDF into the document.

### 5. Document Merging
- **Lines 326-349 (`merge_documents`)**: Merges additional documents into the policy book PDF. It opens source PDF files and imports their pages into the main document.

### 6. Table of Contents Creation
- **Lines 351-412 (`create_toc`)**: Generates the TOC, inserting pages as needed and using the canvas to add text for document titles and categories.

### 7. Adding Page Numbers to TOC
- **Lines 414-454 (`add_toc_page_numbers`)**: Adjusts the TOC to include page numbers for each document, using text drawing methods on the canvas.

### 8. Final Page Insertion
- **Line 169**: Inserts a final blank page into the document.

### 9. Header and Footer Stamping
- **Lines 456-520 (`stamp_pages`)**: Applies headers and footers to each page. This involves canvas operations to draw text and images on each page.

### 10. Saving the PDF
- **Lines 522-533 (`save_policy_book!`)**: Writes the assembled PDF to a file, optimizing it for size.

Throughout this process, the `HexaPDF::Document` object is manipulated through its `pages` collection to add, modify, and annotate pages. Canvas objects retrieved from pages are used for drawing operations (text, lines, images), and the document's configuration settings are applied globally to handle fonts and page layouts.

This overview covers the primary interactions with HexaPDF in your service, mapping out how the PDF is constructed from its initial creation to saving the final document.

You got the wrong line numbers.
```def policy_book_document``` is on line 171.
Please make explicit methods so I can visualize trace down all the interactions to the HexaPDF instance. Reference proper line numbers. I want to see ruby code with comments showing the line numbers

Given the correction about the `policy_book_document` method's location, let's retrace the interactions with HexaPDF in the `PolicyBookBuilder` service, providing explicit method calls and their corresponding line numbers based on the updated information:

### Initialization of HexaPDF Document
```ruby
# Line 171-178: Initializes a HexaPDF::Document object.
def policy_book_document
  @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
    doc.config['page.default_media_box'] = :Letter
    font = doc.fonts.add(font_file)
    unknown_glyph = font.decode_utf8('?').first
    doc.config['font.on_missing_glyph'] = proc { unknown_glyph }
  end
end
```

### Generating the Title Page
```ruby
# Lines 491-537: Creates the title page using canvas operations.
def create_title_page
  title_page = policy_book_document.pages.insert(0)
  page_x, page_y = title_page.box.value[2..3]  # Interacts with the page's box for dimensions.
  page_canvas = title_page.canvas  # Retrieves the canvas for drawing.
  # Drawing operations (text, images) follow...
end
```

### Pre-Table of Contents (TOC) Page Creation
```ruby
# Lines 539-562: Generates a pre-TOC page.
def create_pre_toc
  pre_toc_page = policy_book_document.pages.insert(2)
  # Canvas operations to add text follow...
end
```

### Preface Merging
```ruby
# Lines 564-570: Merges the preface into the document.
def merge_preface
  # Opens a PDF and imports its pages.
end
```

### Document Merging
```ruby
# Lines 572-597: Merges documents into the policy book PDF.
def merge_documents
  # Iterates

Given the updated line number for the `policy_book_document` method starting at line 171, let's trace the interactions with the HexaPDF instance throughout the `PolicyBookBuilder` service with accurate line references and associated operations. The code excerpts below are simplified and annotated to illustrate the process clearly.

### Initialization of HexaPDF Document
```ruby
# line 171
def policy_book_document
  @policy_book_document ||= HexaPDF::Document.new.tap do |doc|
    # Configuration and font setting
    doc.config['page.default_media_box'] = :Letter # Example configuration
  end
end
```

### Generating the Title Page
```ruby
# line 245-291
def generate_title_page
  title_page = policy_book_document.pages.insert(0) # Inserting a new page at the beginning
  page_canvas = title_page.canvas # Getting canvas for drawing
  # Drawing operations with page_canvas follow...
end
```

### Pre-Table of Contents (TOC) Page Creation
```ruby
# line 293-316
def create_pre_toc
  pre_toc_page = policy_book_document.pages.insert(1) # Assuming it follows generate_title_page
  # Further drawing on pre_toc_page's canvas...
end
```

### Preface Merging
```ruby
# line 318-324
def merge_preface
  # Assuming preface is a PDF that needs to be merged
  preface_pdf = HexaPDF::Document.open(preface_path)
  preface_pdf.pages.each do |page|
    policy_book_document.pages << policy_book_document.import(page)
  end
end
```

### Document Merging
```ruby
# line 326-349
def merge_documents
  # Similar process to merge_preface, iterating over documents and importing pages
end
```

### Table of Contents Creation
```ruby
# line 351-412
def create_toc
  toc_page = policy_book_document.pages.insert(2) # This might adjust based on actual implementation
  # Adding TOC content to toc_page's canvas...
end
```

### Adding Page Numbers to TOC
```ruby
# line 414-454
def add_toc_page_numbers
  # Similar canvas operations on TOC pages to add page numbers
end
```

### Final Page Insertion
```ruby
# Assuming this occurs after TOC creation
policy_book_document.pages.insert(-1) # Adding a blank page at the end
```

### Header and Footer Stamping
```ruby
# line 456-520
def stamp_pages
  policy_book_document.pages.each_with_index do |page, index|
    page_canvas = page.canvas(type: :overlay) # Preparing to add headers/footers
    # Applying headers/footers using page_canvas...
  end
end
```

### Saving the PDF
```ruby
# line 522-533
def save_policy_book!
  filename = "path/to/save.pdf"
  policy_book_document.write(filename, optimize: true)
end
```

These snippets and comments illustrate the sequence of interactions with HexaPDF, from creating the document, configuring pages, drawing on canvases, to saving the final PDF. The exact line numbers might still need adjustment based on your complete service file, but this breakdown should provide a clear mapping of HexaPDF operations in your `PolicyBookBuilder` service.

     Failure/Error: expect(builder).to have_received(:add_document_header).and not_to(raise_error)

     NoMethodError:
       undefined method `not_to' for #<RSpec::ExampleGroups::PolicyBookBuilder::Create::AddDocumentHeader "assembles properly" (./spec/services/policy_book_builder_spec.rb:101)>

The error you're encountering in your RSpec test is due to a syntax issue. The `expect` and `not_to` (or `to_not`) methods are part of RSpec's DSL for defining expectations on mocks, stubs, or actual objects. However, they are not designed to be chained directly after `have_received` in the manner you're attempting. Specifically, `and not_to(raise_error)` is not a valid chaining in RSpec.

When you want to assert that a method was called (using `have_received`) and also want to ensure that no error was raised during its execution, you need to handle these as separate concerns within your tests. The `have_received` matcher is used to assert that a specific message has been sent to a double (or a spy), whereas `raise_error` is used to assert that an error is raised when a specific piece of code is executed.

Here's a revised approach to what you might be trying to achieve:

### To Check Method was Called Without Errors
If your goal is to ensure that `add_document_header` was called and did not raise an error during its execution, you should structure your test to explicitly call the method within an `expect { ... }.not_to raise_error` block if you're directly testing error raising. To check if a method was called, you use `have_received` on a spy or a method that was allowed to receive calls.

```ruby
describe '#add_document_header' do
  # Assuming builder is a spy or has been set up to allow :add_document_header
  before do
    allow(builder).to receive(:add_document_header).and_call_original
    begin
      # Directly call the method here if possible, or trigger its call indirectly
      builder.add_document_header(page_canvas, page_x, page_y, title)
    rescue => e
      # If you catch errors here, the test setup is incorrect.
      puts "Error during setup: #{e.message}"
    end
  end

  it 'calls add_document_header without raising an error' do
    expect(builder).to have_received(:add_document_header) # Checks the call was made
    # The not_to raise_error check is implicit in the test passing - errors in before or it blocks will fail the test
  end
end
```

### Important Notes:
- `have_received` only works with test doubles or objects that have been set up with `allow` or `expect` to receive messages.
- The `not_to raise_error` matcher is implicitly applied to all RSpec tests. If an error is raised during the test execution (either in a `before` block or the `it` block itself), the test will fail. You don't need to explicitly assert `not_to raise_error` unless you're testing specific error handling behavior.
- Ensure that the method you're testing (`add_document_header` in this case) is being called as part of the test execution. If it's not directly called in the test or a setup block, RSpec won't be able to intercept it with `have_received`.

Adjust your test according to what exactly you need to verify: whether it's just the call to the method or also its error-free execution.